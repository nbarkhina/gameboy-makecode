// INSTRUCTIONS
// to use your own roms you need to convert them to a makecode image.
// use the utility in the link below to convert a rom. the utility allows
// you to drag a rom onto the page and it will then convert it to a
// makecode image. then click the link on that page to copy the contents
// to your clipboard. then come back to this page and replace the existing 
// romImage below with your new romImage.
// 
// https://www.neilb.net/gbmakecode

let romImage = img`
c9ffffffffffffffffffffffffffffff80402010080402010102040810204080ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe5218dc6c36700ffe5219dc6c36700ffe521adc6c36700ffe521bdc6c36700ffe521cdc6c36700f5c5d52ab6280be53a6e67cd7e00e12318f1d1c1f1e1d9e9ff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
00c35001ceed6666cc0d000b03730083000c000d0008111f8889000edccc6ee6ddddd999bbbb67636e0eecccdddc999fbbb9333e4c696e64736179204164760000000000000000000000000001d74a2df357af3100e021ffdf0e200600320520fc0d20f921fffe0600320520fc21ffff0680320520fc7aea84c6cd2846afe042
e043e041e04a3e07e04b0180ff213f46060a2ae20c0520fa010046cdb745014946cdc9453ee4e047e0483e1be0493ec0e040afe00f3e09e0ffafe026e0023e66e0013e80e002afcdf759fbcd13476d2401007618fdffffffffffffffffffffffc9ffffffc3bc57ffc37a4effffffffffffffffffffffffffffffffffffffffff
e8fef8042a666fe52111c6e5cd5247e804f8042a666fe5cd0f4a2146c6722b73e8022143c636002336002144c67eee805f2146c67eee80572143c67e2145c6967b9ad27f023e112143c6864f3ec6238e470af80177fe20c265021803c365023e0002c374020af8017721a1027ef800227e2b86022143c63420022334c32a0221
45c64e2111c6e53e01f53379f533f80b7ef5332b7ef533cd5a4ae806e802c902085028d802e8fef8042a666fe52111c6e5cd5247e804f8042a666fe5cd0f4a2146c6722b73e8022143c636002336002144c67eee805f2146c67eee80572143c67e2145c6967b9ad224033e112143c6864f3ec6238e470af80177fe20c20a0318
03c30a033e0002c319030af8017721a1027ef800227e2b86022143c63420022334c3cf022145c64e2111c6e53e01f53379f533f80b7ef5332b7ef533cd774be806e802c9e8fe2111c6e5cd0f4a2146c6722b73e8022143c636002336002144c67eee805f2146c67eee80572143c67e2145c6967b9ad2b2033e112143c6864f3e
c6238e470af80177fe20c298031803c398033e0002c3a7030af8017721a1027ef800227e2b86022143c63420022334c35d032145c64e2111c6e53e01f53379f533f8097ef5332b7ef533cd5a4ae806e802c9210fc1360d2110c13600c9214fc63600214fc67e2110c196d24004210000e5210fc17ef533cd4d4ae803210fc134
210000e5210fc17ef533cd4d4ae803210fc134210000e5210fc17ef533cd4d4ae803210fc134210000e5210fc17ef533cd4d4ae803210fc134214fc634c3e203c9214fc63600214fc67efe28d26504210000e5214fc67ef533cd4d4ae803214fc634c34604c92165c636002166c636002167c636002168c636002176c67efe01
c2a8041803c3a8042177c67efe01c2a8041803c3a80421a3027e217ac6772176c63600217bc6360f21a4024e217ac67e817721a2024e79ee805f217ac67eee80577b92d2c704713e0af533217ac67ef533cd163d4be80279179f4721a3c07e81227e88771e80217ac67eee80577b92d2f10521a3c07ec6104f237ece0047216d
c6712370cb2e2bcb1e23cb2e2bcb1e23cb2e2bcb1e2143c636002336002144c67eee805f16802b7ed6037b9ad2f1052ab6c25d051803c35d0521a1c07e2169c67721a2c07e216ac677cb2e2bcb1e23cb2e2bcb1e23cb2e2bcb1ec365052169c634200223342169c67ee61f223600216dc65e23566b6229292929294d442169c6
7e81216fc677216ac67e882170c6773e112b864f3ec1238e470a2171c677b7cae605cdcd092172c67efe01caf1052165c63601216dc65e23566b622929294d4479c6f021a3c07778ceff23772177c67eb7c2de051803c3de052176c63601217ac63600c3f1052143c63420022334c31d05217ac67eee80fe80d2ea0621a3c07e
216dc67721a4c07e216ec677cb2e2bcb1e23cb2e2bcb1e23cb2e2bcb1e2143c636002336002144c67eee805f16802b7ed6027b9ad2ea062ab6c265061803c3650621a1c07e2169c67721a2c07e216ac677cb2e2bcb1e23cb2e2bcb1e23cb2e2bcb1ec370062169c67ec602227ece00772169c67ee61f223600216dc65e23566b
6229292929294d442169c67e81216fc677216ac67e882170c6773e112b864f3ec1238e470a2171c677b7cadf06cdcd092172c67efe01caea062166c63601216dc65e23566b622929294d4479c60821a3c07778ce002377217ac63600c3ea062143c63420022334c3250621a3c07e217ec67721a4c07e217fc677cb2e2bcb1e23
cb2e2bcb1e23cb2e2bcb1e21a3c07ec60f4f237ece00472180c6712370cb2e2bcb1e23cb2e2bcb1e23cb2e2bcb1e1e80217cc67eee80577b92d21b0821a1c07ec6114f237ece00472169c6712370cb2e2bcb1e23cb2e2bcb1e23cb2e2bcb1e2a5e216bc622732143c636002336002144c67eee805f16802b7ed6027b9ad21b08
2ab6c297071803c39707217ec62a5e216dc62273c3a1072180c62a5e216dc622732169c67ee61f223600216dc65e23566b6229292929294d442169c67e81216fc677216ac67e882170c6773e112b864f3ec1238e470a2171c677b7ca1008cdcd092172c67efe01ca1b082168c63601217cc63600216bc65e23566b622929294d
4479c6ef21a1c07778ceff2377c31b082143c63420022334c36e07217cc67eee80fe80d2000921a1c04e23460b2169c6712370cb2e2bcb1e23cb2e2bcb1e23cb2e2bcb1e2a5e216bc622732143c636002336002144c67eee805f16802b7ed6027b9ad200092ab6c27c081803c37c08217ec62a5e216dc62273c386082180c62a
5e216dc622732169c67ee61f223600216dc65e23566b6229292929294d442169c67e81216fc677216ac67e882170c6773e112b864f3ec1238e470a2171c677b7caf508cdcd092172c67efe01ca00092167c63601217cc63600216bc65e23566b622929294d4479c60821a1c07778ce002377c300092143c63420022334c35308
af2179c6b6ca1a092168c67eb7c21a091803c31a09217cc63605af2178c6b6ca4e092167c67eb7c24e091803c34e091e802153c67eee80573e082b967b9ad24909217cc636fbc34e09217cc636002178c67eb7c26d091803c36d092179c67eb7c26d091803c36d09217cc63600217cc67eb7c282091803c38209217dc63600c3
8e09217dc67e217cc686217dc6773e0af533217dc67ef533cd163d4be80279179f4721a1c07e81227e8877217dc67eee80fe8adaba097ec6f6771e76217dc67eee80577b92dacc097ec60a77c92172c636002171c67efe24c2220a1803c3220a1141c33e0012216dc64e2169c6462141c3e5210101e579f53378f533cd774be8
063e11216fc6864f3ec1238e473e00022173c634200223342175c636012172c63601c9e8f221b7c07eb7c27c0a1803c37c0a21b4c07eee805f21b2c07eee805721b3c07e21b1c0967b9ada500ac3870e21b3c07efe3fc2610a237eb7c2670a1803c3670ac3870e21b3c0342002233421b7c0360121b5c0360023360021b3c02a
5e2143c622732b7ee61f2236002147c6360023360021b5c02a5e214dc6227321b5c05e2356210400197d54f8012272214ec67eee805ff8027eee8057214dc67ef801967b9ad2170e214dc65e23566b622929292929297d54f80c227221b3c05e2356f80c2a666f197d54f80a2272113a262b2a666f197d54f80c22725f1af80a
772145c677f80a7e179f2146c6327efe01c21c0b237eb7c2650c1803c3650c2149c63600233600214ac67eee805f16802b7ed6057b9a3e0017f80a77afb6ca5d0c2149c65e23566b6229291929197d54f80c227211bac02b2a666f197d54f80822722b5e2356210700197d54f80622725f1a2b2b77fe02c27e0b3e011801afb7
ca400cf8085e2356210600197d546f623601f8085e2356210500197d546f623600f8085e2356210400197d546f623600f8065e23563e0012235e2356210a00197d546f623600f8085e2356210800197d546f623600f8085e2356210900197d546f62360021b3c05e23566b622929297d54f8062272235e2356f8067e1213237e
12235e2356210200197d54f8062272214dc65e23566b622929297d54f80822722b5e23562108007b955f7a9cf8043273f8065e2356f8037e1213237e12c35d0c2149c65e2356210100197d54f80322722b4e23462149c6712370c3270b2145c636002336002145c67efe02c2760c237eb7c2b10d1803c3b10d2149c636002336
00214ac67eee805f16802b7ed6037b9a3e0017f80077afb6caa90d2149c65e23566b62292919297d54f803227211f1c02b2a666f197d54f80622722b5e2356210800197d54f80822725f1af80577fe02c2d70c3e011801afb7ca8c0df8065e2356210600197d546f623600f8065e2356210500197d546f623600f8065e235621
0400197d546f623600f8065e2356210700197d546f623601f8085e23563e001221b3c05e23566b622929297d54f8082272f8065e2356237e1213237e12f8065e2356210200197d54f8082272214dc65e23566b622929297d54f80a22722b5e23562108007b955f7a9cf80d3273f8085e2356f80c7e1213237e12f8065e235621
0900197d546f623600c3a90d2149c65e2356210100197d54f80622722b46234e2149c6702371c3810c2145c636002336003e412147c6864f3ec3238e472145c67ef80077022147c63420022334214dc65e23566b6229292929294d442143c67e814f237e88472111c1094d44f8007e02214dc67efe0dc2010e237eb7c20c0e18
03c30c0e21b7c03600c3170e214dc63420022334c39f0a21b5c07efe0cc2280e237eb7c2490e1803c3490e21b5c04e2143c6462141c3e5210102e579f53378f533cd774be806c3640e21b5c04e2143c6462141c3e5210104e579f53378f533cd774be806f8012a5e21b5c022732b7efe10c27c0e237eb7c2870e1803c3870e21
b5c03600233600e80ec91e8021a2c07eee80573e642b967b9ad2ed0e7ec69c21afc07721a2c07eceff21b0c07721aec07eee805f21b0c07eee805721adc07e21afc0967b9ad2cf0e2a5e21adc0227321adc04e2346cb28cb19cb28cb19cb28cb1979c61621b1c07778ce002377c9e8fc2143c636052336002143c64e23460b59
506b6229291929197d54f802227211bac02b2a666f197d54f80022722b5e2356210700197d546f6236022143c67123702b2ab6c2f80e2b36032336002143c64e23460b59506b62292919297d54f800227211f1c02b2a666f197d54f80222722b5e2356210800197d546f6236022143c67123702b2ab6c23c0f2b3603233600e8
04c9e8eff8134e2346210700097d54f80f22725f1a2b2b77b7c263131803c36313210500097d54f80c22725f1a2b2b77c6012b22235e2356f80a7e127efe04c2f90f1803c3f90f210400097d54f80822725f1a2377b7c2e90f1803c3e90ff8085e23563e0112c3f10ff8085e23563e0012f80c5e23563e0012210600097d54f8
0822725f1a2377fe01c2e7101803c3e710f80c5e23561af80a77b7ca3110f80c5e23561af80a77fe02c252101803c3521059501af80677131a23325e23562101007b955f7a9cf805327359507e1213237e12210200097d54f80422725f1a2377131a23325e2356210800197d54216dc6227259501af80477131a23327e2169c6
77f8057e216ac677cb2e2bcb1e23cb2e2bcb1e23cb2e2bcb1e7ee61f223600216dc65e23566b6229297d54f80422722169c65e2356f8042a666f197d54216fc622721111c12b2a666f197d54f80422725f1a2171c6773e2a96d2bc11f8085e23563e0212c3bc11f80c5e23561af80477b7ca0711f80c5e23561af80477fe02c2
1c111803c31c1159501af80477131a23322a666f2359507d12137c12210200097d54f80422725f1a2377131a23325e2356210800197d54216dc6227259501af80477131a23325e2356211100197d54f80622722b7e2169c677f8077e216ac677cb2e2bcb1e23cb2e2bcb1e23cb2e2bcb1e7ee61f223600216dc65e23566b6229
297d54f80422722169c65e2356f8042a666f197d54216fc622721111c12b2a666f197d54f80422725f1a2171c6773e2a96d2bc11f8085e23563e011259501af80477131a237721a1c05e2356211000197d54f8062272f8045e2356211000197d54f8082272210200097d54f80c22725f1af80277131a2377ee805f21a4c07eee
8057f8027e21a3c0967b9a3e0017f80a7721a3c05e2356211000197d54f80c22727eee805ff8037eee8057f80c7ef802967b9a3e0017f80b7721a4c07eee805ff8037eee805721a3c07ef802967b9a3e0017f80c77f8025e2356211000197d54f80022727eee805f21a4c07eee8057f8007e21a3c0967b9a3e0017f802773e00
21b9c096d2a21321a9c07efe02c2b5121803c3b512f8062a5e2158c6227321a1c07ec630215ac67721a2c07ece00215bc677c3d31221a1c07ec6e02158c67721a2c07eceff2159c67721a1c02a5e215ac62273f8057eee805f2159c67eee8057f8047e2158c6967b9ada0513215bc67eee805ff8057eee8057215ac67ef80496
7b9ad237132159c67eee805ff8057eee80572158c67ef804967b9adaa213f8097eee805f2159c67eee8057f8087e2158c6967b9adaa213aff80ab6c24413af23b6ca5213aff80cb6c2a213aff802b6c2a213f80f5e23563e0112210a0009363cc3a213f80e7efe01c2a2131803c3a213210a00097d54f80022725f1a2377c6ff
232377f8005e2356f8047e127eb7c2a2131803c3a213f80f5e23563e02122110c13459501a4f131a4721a1c05e23562178007b955f7a9cf801327378ee805f237eee8057792b967b9ad2d813f80f5e23563e02122110c134e811c9e8f9f8094e2346210700097d54f80522725f1a2b2b77fe02c2fe131803c3fe13c3cc165950
1af80577131a23325e235621adc02a666f7b955f7a9cf80332735e2356210800197d542154c62272210200097d54f80222725f1a232377131a23325e2356211000197d542156c622722154c67ec6082158c6772155c67ece002159c6772156c67ec6082160c6772157c67ece002161c677f8047eb7c254151803c35415c53e32
f533210fc17ef533cd4a4be802c12156c67ef802772154c67ef80577c5f8047ef533f8087ef533210fc17ef533cd4d4ae803c1210fc134c53e33f5337ef533cd4a4be802c12158c67ef80177c5237ef5332b7ef533210fc17ef533cd4d4ae803c1210fc134c53e42f5337ef533cd4a4be802c12160c67ef80277c57ef533f808
7ef533210fc17ef533cd4d4ae803c1210fc134210400097d54f80522725f1af80077c643f80577c57ef533210fc17ef533cd4a4be802c1c5f8047ef5332b7ef533210fc17ef533cd4d4ae803c1210fc134c3cc16f8047efe01c2cc161803c3cc16210800097d54f80222725f1af80077c60223225e23562b2b7e1279c6094f78
ce00470a2b77c602232377023e03f533210fc17ef533cd4a4be802f8024e06002156c65e23567b915f7a98f80332737e2b2b222a2236002154c65e2356f8022a666f7b955f7a9cf80632737ef80177c52b7ef533237ef533210fc17ef533cd4d4ae803c1210fc134c53e03f5337ef533cd4a4be802c12156c65e23567b915f7a
98f80632737ef800772158c65e2356f8022a666f197d54f80522722b7ef80177c52b7ef533237ef533210fc17ef533cd4d4ae803c1210fc134c53e03f5337ef533cd4a4be802c12160c62a666f097d54f80522722b7ef800772154c65e2356f8022a666f7b955f7a9cf80632737ef80177c52b7ef533237ef533210fc17ef533
cd4d4ae803c1210fc134c53e03f5337ef533cd4a4be802c12160c67e814f237e8847f800712158c646234e5851f8022a666f19454cf8007ef53378f533210fc17ef533cd4d4ae803210fc134e807c9e8f3f80f4e2346210800097d54f80b22725f1a2b2b77b7c258191803c3581921a3c05e2356211100197d54f80822722102
00097d54f80622725f1af80477131a2377ee805ff8097eee8057f8047ef808967b9ad2ce17f8045e2356210800197d54f806227223237eee805f2b2b7eee8057237e2b2b967b9ad2ce1721a1c05e2356211000197d54f806227259501a2377131a2377ee805f2b2b7eee8057237e2b2b967b9ad2ce1723235e2356213000197d
54f8022272f8077eee805ff8037eee8057f8067ef802967b9ad2ce1723235e23562110007b955f7a9c21a4c032732109000936012177c67eb7c2c6171803c3c6172176c63601217ac63600c3d417210900093600210500097d54f80222725f1a2377c6012b2b5e235612210400097d54f80422725f1a2377c6012b2b5e235612
210700097d54f80622725f1a2377fe01c29b181803c39b18f8045e23561af80877fe03c278181803c3781859501af80877131a23325e23562101007b955f7a9cf801327359507e1213237e12f8045e23563e0012210900097d54f80022725f1af80877fe01c278181803c3781821a1c05e23561b2b732372f8025e23561af800
77fe78c29b181803c39b18f8025e23563e0012f8065e23563e0212f8065e23561af80077fe02c222191803c32219f8045e23561af80077fe03c2ff181803c3ff1859501af80077131a23322a666f2359507d12137c12f8045e23563e0012210900097d54f80022725f1af80477fe01c2ff181803c3ff1821a1c03420022334f8
025e23561af80077fe78c222191803c32219f8025e23563e0012f8065e23563e011259501a4f131a4721a1c05e23562178007b955f7a9cf801327378ee805f237eee8057792b967b9ad25819f80b5e23563e02122110c134e80dc9e8fbf8074e2346210800097d54f80322725f1a2b2b77fe02c27e191803c37e19c3941a5950
1af80377131a23325e235621adc02a666f7b955f7a9cf80132735e2356210800197d542154c62272030359501a4f131a4779c6102156c67778ce0023773e2af533210fc17ef533cd4a4be8022156c64e2154c646c579f53378f533210fc17ef533cd4d4ae803e14d210fc134c53e2af5337ef533cd4a4be802e14d2154c65e23
56210800197d54f80022722b46c579f53378f533210fc17ef533cd4d4ae803e14d210fc134c53e2af5337ef533cd4a4be802e14d2154c65e2356211000197d54f80022722b46c579f53378f533210fc17ef533cd4d4ae803e14d210fc134c53e2af5337ef533cd4a4be802e14d2154c65e2356211800197d54f80022722b4679
f53378f533210fc17ef533cd4d4ae803210fc134e805c9e8fc21aac07e21a9c0be2003c3b61a21a0027e21a7c07721a9c07e21aac07721a0024e21a7c07eb9c2b11b1803c3b11b21a7c0360021a8c03421a9c07efe01c2371b1803c3371b21a8c07efe02c2131b1803c3131b210104e5cd4a4be802210205e5cd4a4be8022103
14e5cd4a4be802210415e5cd4a4be802c3371b210106e5cd4a4be802210207e5cd4a4be802210316e5cd4a4be802210417e5cd4a4be80221a9c07efe02c29e1b1803c39e1b21a8c07efe02c27a1b1803c37a1b210108e5cd4a4be802210209e5cd4a4be802210318e5cd4a4be802210419e5cd4a4be802c39e1b21010ae5cd4a
4be80221020be5cd4a4be80221031ae5cd4a4be80221041be5cd4a4be80221a8c07efe02c2b11b1803c3b11b21a8c0360021a1c07e21adc0964f21a2c07e21aec09e4779c6082154c67778ce00237721a3c07ec6112156c67721a4c07ece002157c6772154c62a5e2152c622732154c67ec6082158c6772155c67ece002159c6
772156c67ec6082160c6772157c67ece002161c6772156c64e2154c646c579f53378f5333e01f533cd4d4ae803c12158c67ef80377c579f5337ef5333e02f533cd4d4ae803c12160c67ef80277c57ef53378f5333e03f533cd4d4ae803e14dc5f8047ef533237ef5333e04f533cd4d4ae803e14d3e0021b9c096d2491f3521a9
c07efe02c2f01d1803c3f01d2154c67ec6102158c6772155c67ece002159c6772154c67ec618215ac6772155c67ece00215bc6772154c67ec620215cc6772155c67ece00215dc6772154c67ec628215ec6772155c67ece00215fc677c521050ce5cd4a4be802e14dc521060de5cd4a4be802e14dc521070ee5cd4a4be802e14d
c521080fe5cd4a4be802e14dc521091ce5cd4a4be802e14dc5210a1de5cd4a4be802e14dc5210b1ee5cd4a4be802e14dc5210c1fe5cd4a4be802e14d2158c646c579f53378f5333e05f533cd4d4ae803c1215ac67ef80377c579f5337ef5333e06f533cd4d4ae803c1215cc67ef80177c579f5337ef5333e07f533cd4d4ae803
c1215ec67ef80077c579f5337ef5333e08f533cd4d4ae803c1c5f8047ef53378f5333e09f533cd4d4ae803e14dc5f8047ef533237ef5333e0af533cd4d4ae803e14dc5f8047ef5332b7ef5333e0bf533cd4d4ae803e14dc5f8047ef5332b2b7ef5333e0cf533cd4d4ae803e14dc3b11f2154c67ec6e02158c6772155c67eceff
2159c6772154c67ec6e8215ac6772155c67eceff215bc6772154c67ec6f0215cc6772155c67eceff215dc6772154c67ec6f8215ec6772155c67eceff215fc677c521052ce5cd4a4be802e14dc521062de5cd4a4be802e14dc521072ee5cd4a4be802e14dc521082fe5cd4a4be802e14dc521093ce5cd4a4be802e14dc5210a3d
e5cd4a4be802e14dc5210b3ee5cd4a4be802e14dc5210c3fe5cd4a4be802e14d2158c646c579f53378f5333e05f533cd4d4ae803c1215ac67ef80077c579f5337ef5333e06f533cd4d4ae803c1215cc67ef80177c579f5337ef5333e07f533cd4d4ae803c1215ec67ef80377c579f5337ef5333e08f533cd4d4ae803e144f802
7ef53378f5333e09f533cd4d4ae803f8027ef5332b2b7ef5333e0af533cd4d4ae803f8027ef5332b7ef5333e0bf533cd4d4ae803f8027ef533237ef5333e0cf533cd4d4ae803c3b11f210000e53e05f533cd4d4ae803210000e53e06f533cd4d4ae803210000e53e07f533cd4d4ae803210000e53e08f533cd4d4ae803210000
e53e09f533cd4d4ae803210000e53e0af533cd4d4ae803210000e53e0bf533cd4d4ae803210000e53e0cf533cd4d4ae803e804c921a5c03600cd2e4b4b79e6012003c3cf1f21a5c0360121a9c03602cd2e4b4b79e6022003c3e51f21a5c0360121a9c03601cd2e4b4b79e6102003c3f91f2177c63601c3fe1f2177c63600cd2e
4b4b79e6202003c3312021b9c07eb7c229201803c3292021b8c07eb7c229201803c3292021b9c0361e21b8c03601c3362021b8c03600af21a5c0b6ca462021a7c03421a6c03421a6c03600cd2e4b4b79e6022003c35f202178c63601c364202178c63600cd2e4b4b79e6012003c378202179c63601c37d202179c63600c9e8fe
2143c636682336012143c64e23460b2141c3097d54f80022722b5e23563e00122143c67123702b2ab6c288202b36682336012141c3e5211412e5210000e5cd774be806e802c9e8fe21a0c03600cd7e20cd41042143c636682336012143c64e23460b2141c3097d54f80022722b5e23563e2c122143c67123702b2ab6c2db202b
36682336012141c3e5211412e5210000e5cd774be806210796e5cd354ae8020143ff3e000221010fe521a421e5cda502e804210510e521b721e5cda502e8041141c33efa122141c3e5210101e521090fe5cd774be8062141c3e5210101e5210a10e5cd774be806217c354e234621f635e579f5333e00f533cd6e4ae804217835
4e23462176352a5ef80022732b46217e35e579f53378f533210404e5cd774be806e802c94c494e445341595320414456454e5455524500505245535320535441525400e8fd0148ff3ed00221c2294e234621742ae579f5333e00f533cd6e4ae8040140fff80136402336ff2b5e23561a2b2b777ff620020140ff2336402336ff
2b5e23561a2b2b777ff601020140ff2336402336ff2b5e23561a2b2b777ff60202e803c9e8f521a1c0363223360021a3c0362823360021a5c0360021a6c0360021a7c0360021a8c0360021a9c0360221aac0360121abc0360023360021adc0360023360021afc0360023360021b1c0361523360021b3c036ff2336ff21b5c036
0023360021b7c0360021b8c0360021b9c036002173c636002336002175c6360121a0c0360121c2294e234621742ae579f5333e00f533cd6e4ae804cd7e20cd41042143c636302336022143c64e23460b2111c1097d54f80922722b5e23563e00122143c67123702b2ab6c2c9222b3630233602cdee0e21b3c036ff2336ff2164
c636002164c67efe58d21623cd230a2164c634c303232145c636002336002146c67eee805f16802b7ed6047b9ad2e4232143c636002336002144c67eee805f16802b7ed6027b9a3e0017f80077afb6cab9231141c32143c62a666f197d54f80922722143c65e2356213000197d54f80722722145c65e23566b62292929297d54
f8052272235e2356f8052a666f197d54f80322722b7ef8095e2356122143c65e2356210100197d54f80122722b46234e2143c6702371c338232145c67ec6064f237ece00472141c3e5210201e579f5333e02f533cd774be8062145c63420022334c31e232143c636682336012143c64e23460b21a9c4097d54f80122722b5e23
563e01122143c67123702b2ab6c2ec232b366823360121a9c4e5211404e5210000e5cd5a4ae806210770e5cd354ae802210401e5216724e5cd0002e80421c2294e234621742ae579f5333e00f533cdbb4ae804210002e5cd4a4be80221a0027e21a7c077e80bc953434f524500e8f6cdc321cdc620cd114621a0c07eb7c29424
1803c39424cd2e4b4b79e6802003c39424cd242221a0c07efe01c22b261803c32b260143ff21adc07e02cdd203cdb41fcd6604cd8a0ecd971a2143c636002336002144c67eee805f16802b7ed6057b9a3e0017f80077afb6ca50252143c65e23566b6229291929197d54f808227211bac02b2a666f197d54f80622722b5e2356
210700197d54f80422725f1af80177fe02c218253e011801afb7c23325f8062a666fe5cd820fe802f8062a666fe5cddb13e8022143c65e2356210100197d54f80222722b46234e2143c6702371c3c1242143c636002336002144c67eee805f16802b7ed6037b9a3e0017f80177afb6cae6252143c65e23566b62292919297d54
f802227211f1c02b2a666f197d54f80422722b5e2356210800197d54f80622725f1af80077fe02c2ae253e011801afb7c2c925f8042a666fe5cdcf16e802f8042a666fe5cd5b19e8022143c65e2356210100197d54f80822722b46234e2143c6702371c35825cddd03cd230acd2e4b4b79e6402003c3fb25cdc6202175c67efe
01c22b261803c32b262173c62a666fe5213726e52111c6e5cd5247e806210a01e5cd4403e8022175c636000126ff3e0002c37524e80ac92564002b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2b0000000000
000000000000000000000000002b2b00000000000000000000000000002b2b2b2b2b0000000000000000000000000000000000000000000000002b0000000000000000000000000000000000002b2b0000000000000000000000000000002b2b2b000000000000000000000000000000000000000000000000002b0000000000
000000000000000000000000000000000000000000000000000000000000002b00000000000000000000000000000000000000000000000000002b0000000000000000000000000000000000000000000024240000000000000000000000000000000000000000000000000000000000000000000000000000002b0000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b0000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002b0000000000000000000000000000000000000000000000000000000000242400000000000000000000000000000000000000000000000000000000000000002b0000000000
000000000024240000000000000000000000020000000000000000000024242400000000000000000000000000000024242424000000000000002b0000000000000000000000000000002b2b0000000000000000000000000000000000002a2a2a000000000000000000000000000000000000000000000000002b0000000000
000000000000000000002b2b000000000000000000000000002b2b000000000000000000000000000000000000000000000000000000000000002b0000000000000000000000000001002b2b00000000010000000001002b2b2b2b000000000000010000000000000000000000000000000000000000000000002b2b2b2b2b2b
2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2b2a2a2a2a2a2a2a2a2a2a2a2a2a2a2a2ab00010000b00000bb000000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b
3c3d3e3f404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf000000000000000000000000
00000000ff00ff00ff00ff00ff00ff00ff00ff003e3e417f14220022001c1800182400663c3c42429999a1a1a1a1999942423c3c0073003e0c331e617f406d52ff80f3cc0000000000008080808080808080808000000073003e0c331e617f406d52ff8000000000000000008080808080808080000000000000000001010101
01010101000000ce007c30cc7886fe02b64aff010000000000000101010101010101010100ce007c30cc7886fe02b64aff01cf330000000000000000000f0ff2ff02ff02000000000000003f3fc0ff11ff12ff120000000303fcff00ff00ffe1ff12ff12000f0ff0ff00ff00ff00ffe0ff10ff1000000000020c031007100019
003d0f300000000000000000008000820002fc0201010000020207000f080f000c000c00808000004040e000e000f000101008007f613f311f1f1f101f101f1b2c2c080880800000bcbce4fcc23ec23efc84fefef3cc7f611f1f3f305f580f0c0b0b101080808080dcdce43cc23ec2befcc43e3e010101013b3b273c437c437d
3f237c7ccf33fe86f8f8fc0cfa1af030d0d00808010100003d3d273f437c437c3f217f7ffe86fc8cf8f8f808f808f8d834341010ff02ff03ff0200ff0000000000000000ffd3ff32ff12ff0000ff000000000000fff3ff12ff12ff0000ff000000000000fff0ff10ff10ff00ff0000ff00000000003f1f201f20003f003f1f20
0020002000fefc02fc0200fe00fefc02000200020c000c000c000c000c000c000c0807074800086008000800004000100000e0e01818243c427e7e427e427e423c241818000000003c3c444444444c4c3434000000004040787844444444444478780000000000003c3c4040404040403c3c0000000004043c3c444444444444
3c3c000000000000383844447c7c40403c3c0000fffffb040bf4f00f0ff0d02fdf20ffffffffbdc3dba5ff81ff81dba5bdc3ffff00f0f00fff00ff00ff00ff08ff08ff08000000c0c03fff00ff00ff47ff48ff4800000000000000fcfc03ff87ff48ff48000000000000000000f0f08fff40ff40000100070f0f080f131c0f12
0f100f14008000e0f0f010f0d038f048f008f04800001c1c372f283f3b3e303f131f1f1100007070d8e828f8b8f818f890f0f01000ff242418183c3c42427e7e424200ff00000000000000000000c0c0fcbcc7bf000000000000000000003c3cf6fa9a7e00ff3c3c42424040404042423c3c00ff00ff101000007e7e40407c7c
404000ff00ff08081c1c7e7e40407c7c404000ff00ff282800007e7e40407c7c404000ff00ff242400007e7e40407c7c404000ffff0bff0cff08ff00ff0000ff00000000ff4fffc8ff48ff0000ff000000000000ffcfff48ff48ff0000ff000000000000ffc0ff40ff4000ff0000000000000000071b1b241c23374f077f0707
07073737c0bc98647886ecf2e0fee0e0f0f0fcfc0e090f0f1f18171c171c171c3f223f3fe020e2e2f636de7adc74d878f888f8f8e020e0e0f636df79de72dc7cf888f8f8ffbaffc2fe83ffc2ffbac7bffcbce0e0867ec47cd4ecc47c867e9a7ef6fa3c3c0000000044442828101028284444000000003e3e46464a4a52526262
7c7c00002020101042424242424242423c3c00000404080842424242424242423c3c00001818242400004242424242423c3c00000000242400004242424242423c3c00000404080844442828101010101010000000004040707048484848707040400000000078784444484844444444585800004f4f4f6f3f3f0f0f1f1f1f1f
1f1f3f3ff2f6f2f2fafafcfcf8f8f8f8fcfcfcfc189824a400803cbc44c44ccc34b400801414282800003c3c44444c4c343400000000242400003c3c44444c4c343400001818181800003c3c44444c4c343400000000000000003c3c4a4a5c5c2e2e0000000000003c3c4040404040403c3c0808202010100000383844447c7c
40403c3c040408080000383844447c7c40403c3c181824240000383844447c7c40403c3c000024240000383844447c7c40403c3c202010100000101010101010101010100808101000001010101010101010101010102828000010101010101010101010000028280000101010101010101010107f7f7f7f0404040404040404
1c1c1c1cfefeffff20202020202020203838383820a01090008038b844c444c438b800800808101000003838444444443838000010102828000038384444444438380000141428280000383844444444383800000000282800003838444444443838000000000000101000007c7c000010100000000000003c3c4c4c54546464
78780000202010100000444444444c4c34340000080810100000444444444c4c34340000101028280000444444444c4c34340000000028280000444444444c4c3434000008081010000044444444282810106060000040406060505050506060404000000000282800004444444428281010606000ff222236361c1c0c0c1e1e
3030000000ff404040404040404000004040000000806c6c242448480000000000000000000024247e7e242424247e7e2424000010103838545450503838141454543838000000002424080810102424000000000000303048485050202054544848343400001818080810100000000000000000000008081010101010101010
08080000000010100808080808080808101000000000000010105454383854541010000000000000101010107c7c101010100000000000000000000060602020404000000000000000007c7c0000000000000000000000000000000000000000404000000000020204040808101020204040000000003c3c626252524a4a4646
3c3c00000000181828280808080808083c3c000000003c3c424202023c3c40407e7e000000007c7c02020c0c020202027e7e000000004040404048487e7e08080808000000007e7e40407c7c020202027c7c000000003c3c40407c7c424242423c3c000000007e7e02020404080810102020000000003c3c42423c3c42424242
3c3c000000003c3c424242423e3e02023c3c00000000181818180000000018181818000000001818181800001818181808081010000000000c0c3030404030300c0c00000000000000007c7c00007c7c00000000000000006060181804041818606000000000303048480808303000002020000000001c1c22224d4d55555555
2e2e000000003c3c424242427e7e42424242000000007c7c42427c7c424242427c7c000000003c3c42424040404042423c3c000000007c7c42424242424242427c7c000000007e7e40407c7c404040407e7e000000007e7e404040407c7c40404040000000003c3c424240404e4e42423e3e000000004242424242427e7e4242
4242000000007c7c10101010101010107c7c000000007c7c101010101010101060600000000044444848505070704848444400000000404040404040404040407e7e00000000424266665a5a424242424242000000004242626252524a4a46464242000000003c3c42424242424242423c3c000000007c7c424242427c7c4040
4040000000003c3c424242424a4a44443a3a000000007c7c424242427c7c42424242000000003e3e40403c3c020242423c3c000000007c7c1010101010101010101000000000424242424242424242423c3c00000000444444444444282828281010000000004242424242425a5a666642420000000042422424181818182424
424200000000444428281010101010101010000000007c7c04040808101020207c7c0000000018181010101010101010181800000000404020201010080804040202000000001818080808080808080818180000000010102828000000000000000000000000000000000000000000003c3c000078000c000a00200772000001
02030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d22222e2f30313233343536373822393a3b3c3d3e3f40414243224445464748494a4b4c4d4e4f505152535455565758595a5b5c5c5d5e5f60616263646566676869296a6b6c6d6e6f707100ff00ff00ff00ff00ff
18e718e718e701fe01fe00ff00ff01fe01fe03fc04fbff00ff007f80ef00fe01f807e41be817a45bc03ff807c23d00ff03ff1fff7fff01ff02ff03ff01f804f8e1f0e6e189e6bfffd3ff80ff40ff641be807eb0458e0fbff70ff02ff18ff00ff748bf8073f00ffff10ff00ff00ff00ff00ff00ffc03fffff7fff1fff738f01ff
00ff70ff26ffffffffffffffffffffff7fff3fff3fff80ff80ff80ff80ff84ffc3ff81ff80ffffffffff7fff7fffffffffffffff5fff08f700ff00ff00ff02fd07f807f8c3fc01fe0ff00ff017e807f837c8cf30fd02d02fe11fc03fc03f817f837fc33f877f7eff7efffdfffdfefcfff9ff89f72add17e87bf02ff01fe00fe0
1fc05f801f800ff0ef00f000f600ff00ff00ff00ff000e00ff00ff003f001f00ff00fb00fd00f807f807ff00ff00fa0520df807f927f01ff00ff20df9867ce3100ff00ff40ff9fff0fff67ff03ff01ff09ff00ff00ff80ff80ff80ff00ff00ff0eff2cff04ff1fff0fff0fff07ff07ff03ff03ff03ffc0ffc0ffc0ffc0ff80ff
01fe01fe00ff3fc01ee12ed15ca309f68f7007f80ff007ff0fff0eff0eff0fff1fff1fff1fff56b939f26ff0ffe0dfe0dfe0b7c82cd3bf00b7087f00ff00ff00ff00ff00fc00ff00fb04fd02fa05ff00ff0006000000ff00ff00bc4312ed08f7fc033f000300c03fe01f00ff00ff00ff00ff8778ff0000ff01fe1be41fe03fc0
7f80ff00ff0020ffc03fe01ff00ff807fa05fc03fe0100ff00ff00ff00ff00ff00ff00ff00ff03ff01ff00ff00ff00ff00ff00ff00ff00ff00ff00ff04fb04fb00ff00ff1eff07f802fd06f907f807f806f902fd02fd1fff1fff1eff0fff0eff0aff1cff0fff29d647b84bb407f80df203fc05fa0ff0f000f000e000e000e000
e000f000e8000000000000000000000000000000000003000400030001000100000000000000ff00ff00ff007f00ff001f003f003f00ff00ff00ff00ff00ff00ff00ff00ff00e8178a75aa55b24df00ff807f807f8073eff78ffe0ffeefffefffcfff8fff1ff02fd06f906f906f900ff00ff04fb00ff0cff00ff02ff06ff00ff
00ff00ff00ff7f807f807f807f807f807f803fc03fc0ff00ff00ff00ff00fe009c002000a0000000c0008000000000000000000000000000000000000000010003001f001f003f003f007f007f00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00fe01fc03f807f807fc03ff00ff00ff007f800ff000ff00ff00ff00ff00ff
807f807f807ffafff4fffdff7ffffffffcfffcfff8ff08f700ff10ef80ff00ff00ff00ff00ff00ff00ff00ff01ff01ff20df00ff40bf3fc01fe00ff01f8003000300f7007f80e000e00080008000800080008000800000000000010003000f000000010006011f007f00c23d817efe01ff00b04f3cffff00ff00ff00ff00ff00
ff007f806780f00fc03fc03fc03fc33fcf3fcb3fcf3fe3fc03fc7f800ff0c7f837f847b81fe0807f807f807f807f807f807f807f807fe2fffcfffcfffdfffafffafff8fff1ff00ff00ff01fe02fd00ff20ff10ff00ff807f20df20df40bf00ff00ff00ff00ff278049860bc42ec00ce007e010e008f080004000800080008000
c000400000000e010e01000000000000000000000000fefdbf78ff003f001e000000000001006380810081000000000000000000e000e41bfd02ff00ff00ff007f00730c7b043fc0ff00ff00ff00ff00ff00ff00ff00807f807fa07fa07f807fa07f807f807f00ff03fc1fe07f801fe01fe01ee100ffe3ffe3ffe3ffe6ffc7ff
c7ffffffffff0cff0cff1eff7efffefffffff9ffffff40ff80ff60ff11fef0ffc0ffc3fcc7f800f800fc02fc04fb44bbc837807f807f800000000000980000f804f800fc00fe00000000000000000000000000000300030007000e011e013d027906f906f10ec000c3005986fe01ff00ff00df00f807f906c13e05fa9f60fc03
fc03807f08ffff00ff00ff00ff0027d807f816e97e81807fc07f00ff00ff00ff00ff06f927d800ff2fd0ff00ff007f807f80ff00ff00ffffffffffffffffffffffffffffffffcff0dee19fe09fe03fc07e817e81ff0047b8c738c738f708fe00f800c0000000ad529760df000d000600760000000000030007000f0087009f00
0f0007000100f00ff00ff30cf708f708ff00ff00ff000dff40bffc03fd02fe01fe01ff00ff00e0ff0ff017e89f600ff0ff00ff01ff035ea1fc03bc43fd02fb04ff007f807e806f90cf30bf40ff00ff00ff00ff007f00ff00ff00ff00ff00ff00ff00f807e01ffcffffffefffe3fff3fff8fffcffffff7eff3cff8cffc4ffe4ff
ecff30ff00fffc00e81020c000c040800080800000000000000000001000000000000000000000000000000008000000040002000100ff00ff00fe01ff00ff00ff007f007f00ff00ff007f80fc03ff00ff00ff00ff00f907f10ff00ff807f807fc03fc03fc03ff80ff80ff80ff80bfc019c000c004c03f00fe00ff00ff009f00
1f001f001f00a05f807fc03fc03fa01fd708cf00e700210300395e2b6e4dcd963d5950c9210300395e2b6e4dcd963dc921050039562b5e2b7e2b6e67444dcd9e3d5950c921050039562b5e2b7e2b6e67444dcd9e3dc9210300395e2b6e4dcdd83d5950c9210300395e2b6e4dcdd83dc921050039562b5e2b7e2b6e67444dcddb
3d5950c921050039562b5e2b7e2b6e67444dcddb3dc979079f477b079f5778eaddc6aaeadec6cb7a280697935f9f9257cb78280697914f9f9047cddb3dd8fadec6e680280697914f9f9047faddc6e680c897935f9f9257c90600507bb22007010000505937c96960010000b73e10eadfc6cb15cb14cb11cb10c5799b4f789a47
3f3803c118023333fadfc63d20e05059cb154dcb1444b7c9c5f8047ecd1d4dc1c9c5f8047ecd464dc1c9f8022aeaf6c67eeaf7c6c9fa85c6e6022005c5cd7a4ec1faf6c65fc9fa85c6e6022005c5cd7a4ec1faf7c65fc9e52109c73e13be280334180f3600210ac73e11be28033418023600e1c978eafcc679eafec6afeafdc6
7aeaffc62f6f26ff23010000097dea04c77cea03c7fafdc647faffc690d8fafbc6b7ccab3ffa03c7cb7f282dfafbc6b7c4173ffafdc63ceafdc6fa03c747fa04c74f2600fafdc66f292909010600097cea03c77dea04c718bcfafbc6b7c44f3ffafdc63ceafdc60600fafdc64f26fffaffc62f6f2309fa03c747fa04c74f2929
09010a00097cea03c77dea04c7faffc63deaffc6c3953efafcc647fafec64ffafdc657faffc65fc5d578936778834779824f5459cdff40d1c17ab7c8c5d578936778834779924f5459cdff40d1c1c9fafcc647fafec64ffafdc657faffc65fc5d578936778834779824f5459cdff40d1c1c5d578936778834779924f5459cdff
40d1c17a93c8c5d578926778824779934f5459cdff40d1c1c5d578926778824779834f5459cdff40d1c1c9fafcc647fafec64ffafdc657faffc65fc5d578824779934fcd9043d1c1c5d578934779924fcd9043d1c1c5d578924779834fcd9043d1c1c5d578834779824fcd9043d1c17ab7c893c8c5d578924779934fcd9043d1
c1c5d578934779824fcd9043d1c1c5d578824779834fcd9043d1c1c5d578834779924fcd9043d1c1c9fafcc647fafdc64f90300879eafcc678eafdc6fafec647faffc64f90300879eafec678eaffc6fafcc64757fafec64ffaffc65fcdff40fafdc64757fafec64ffaffc65fcdff40fafcc63ceafcc6fafdc63deafdc6fafcc6
47fafdc657fafec64f5fcdff40fafcc647fafdc657faffc64f5fcdff40fafbc6b7c8fafcc647fafdc690d8fafec63ceafec6faffc63deaffc6fafec647faffc690d8faf8c64ffaf9c6eaf8c679eaf9c6fafcc647fafdc657fafec64f5fcdff40faffc647fafec6b828063ceafec618e0faf8c64ffaf9c6eaf8c679eaf9c6c979
9330022f3cea01c767789230022f3cea00c794da7c427892d22741799328143e0030103eff180c7b9128063e0030023eff424bea02c721a55816005919192a666f78e6f85f1919fa01c7b7ca2042e526006f297cea05c77dea06c7545dfa00c72f6f26ff23197cea03c77dea04c7fa00c72f6f26ff23fa01c716005f19297cea
07c77dea08c7e1fa00c75f78e607c6104f06000a474fcb09fa03c7cb7f2828d5cb79280a782f4fcdad432b0e8041fa04c757fa06c782ea04c7fa03c757fa05c78aea03c7d11841d5c5782f4fcdad43fa02c7b7280c237de60f201411300119180e2b2b2b7de60fee0e200411d0fe19fa04c757fa08c782ea04c7fa03c757fa07
c78aea03c7c141d1cb792807d511100019d14178b1471dc29641782f4fc3ad43fa00c75f1c78e6072814e5c6106f26004ee1af0fb11d280ecb4728f718087b3de6f82829180c472f4fd5cdad43110f0019d17bb7c8e6f82814af4f2f47d5cdad43110f0019d17bd608c85f18e53e801d2804cb2f18f9472f4fc3ad437993d28d
42789228143e0030103eff180c799328063e0030023eff424bea02c721a55816005919192a666f78e6f85f1919fa01c75f1cfa00c7b7ca6f43e526006f297cea05c77dea06c7545dfa01c72f6f26ff23197cea03c77dea04c7fa01c72f6f26ff23fa00c716005f19297cea07c77dea08c7e1fa01c75f78e607c6104f06000a47
4fd5c5782f4fcdad43237de60f200411300119c1fa03c7cb7f2818fa04c757fa06c782ea04c7fa03c757fa05c78aea03c71832fa02c7b7200ccb00cb40281011f0ff19180acb08cb78280411100019fa04c757fa08c782ea04c7fa03c757fa07c78aea03c7d11d2098782f4fc3ad4378e607e5c6106f26007ee1472f4fd5cdad
43237de60f200411300119d11dc818ed21a55816005919192a666f78e6f85f191978e607c6104f06000a472f4ffaf8c657fafac6fe012829fe02283ffe03285558cb422003c50600cb4a20021e00f041cb4f20fa7ea1b0227ea1b37778b7c0c1c948cb4220020600cb4a20020e00f041cb4f20fa7eb0227eb177c948cb422002
0600cb4a20020e00f041cb4f20fa7ea8227ea977c941cb42280206ffcb4a28020efff041cb4f20fa7ea0227ea177c921a55816005919192a666f78e6f85f191978e607c6104f06000a4ff041cb4f20fa2a572a5f06007aa12802cbc07ba12802cbc858c921a5581600fa0ac70707075f191946236668fa09c70707075f191979
444d626f29292911bc4f19545d6069faf8c64f1a13d5e521f9c66e47afcb4528012fb0cb412001a857afcb4d28012fb0cb492001a85fe1f041cb4f20fa7a227b22d17de60f20ccc9f8022aea09c72aea0ac7c9c5fa85c6fe01c4bc57f8047e4fcd6444cd573ec1c9c5f8042a472a4fcd2f44c1c9f8022aeaf8c62aeaf9c67eea
fac6c9c5fa85c6fe01c4bc57f8042a472a4f2a577eeafbc6cd743ec1c9c5fa85c6fe01c4bc57f8042aeafcc62aeafec62aeafdc62aeaffc67eeafbc6cd2940c1c9c5fa85c6fe01c4bc57f8042a472a4f2a572a5fcdff40c1c9c5fa85c6fe01c4bc57f8042a472a4fcd9043c1c9c5fa85c6fe01c4bc57f8042a472a4f2aeaf8c6
2aeafac6cd9043c1c97dea85c6e6036f01e001cb25cb2509e9218dc6c3d545219dc6c3d54521adc6c3d54521bdc6c3d54521cdc6c3d545218dc6c3f545219dc6c3f54521adc6c3f54521bdc6c3f54521cdc6c3f5452a5f56b2c87bb920f77ab820f3af32773c545d1b232a1247132a1213b0c818f52ab628032318f9702b71c9
218bc63420022334cd80ff3e01ea89c6c9f04087d0aff3ea89c6fb7600fa89c6b728f8afea89c6c9f04087d0f044fe9230faf044fe9138faf040e67fe040c93ec0e0463e283d20fdc9fa88c6fe022009f001ea87c63e00180efe012016f001fe5528043e0418023e00ea88c6afe0023e66e0013e80e002c9f8026e2600cd8945
c92185c65ec9fbc9f3c9fa84c6c35001f3f802afe00f7ee0fffbc9c5f8044e2346cd9945c1c9c5f8044e2346cd9f45c1c9c5f8044e2346cda545c1c9c5f8044e2346cdab45c1c9c5f8044e2346cdb145c1c9c5f8044e2346cdb745c1c9c5f8044e2346cdbd45c1c9c5f8044e2346cdc345c1c9c5f8044e2346cdc945c1c9c5f8
044e2346cdcf45c1c9218bc6f32afb565fc9c9e1fa8ac6f55e2356232a23e5ea8ac6ea0020212c47e56b62e9e1f1ea0020ea8ac6e9f8024d4469602323e5210000e521d449e5f8082a666fe5cd5d48e808c9e8fcf8024d445950f8067e1213237e12f8087d54f80022722b2a666f2323c5e5c521df49e5f8102a666fe5cd5d48
e808c1c53e00f533cddf49e803e804c9e8fcaff80ab6cacb47f8064e234678cb7fcacb47f80b4e2346232a666fe53e2df53321b947e56960e9e803f8064e2346af994f3e0098472b712370f8062a23962b2a239eda05482b2a666fe5f8082a666fe5cd703d424be804f80d2a666fe5f80d2a666fe53e00f533f80d2a666fe5c5
cd9047e809f80b4e2346c5f80a2a666fe5f80a2a666fe5cd843df809722b73e804c1114c48f8022a666f197d54f80022725f1a2377f80d2a666fe5f8047ef533214748e56960e9e803e804c93031323334353637383941424344454600e8fbf8074e23460af80177afb6cad1497efe25c2a7491803c3a74903f8077123700a4f
fe63caa04879fe64cafc4879fe73ca5e4979fe75cacb4879fe78ca2d49c3bf49f80d4e2346032b7123700b0a4ff80471f80946234e232a666fe5f8067ef53321c648e56861e9e803c3bf49f80d4e234603032b7123700b0b59501a4f131a47f80b2a666fe5f80b2a666fe53e00f533210a00e5c5cd9047e809c3bf49f80d4e23
4603032b7123700b0b59501a4f131a47f80b2a666fe5f80b2a666fe53e01f533210a00e5c5cd9047e809c3bf49f80d4e234603032b7123700b0b59501a4f131a47f80b2a666fe5f80b2a666fe53e00f533211000e5c5cd9047e809c3bf49f80d4e234603032b7123700b0b59501a4f131a47f802712370f8025e23561af80077
afb6cabf49f8094e2346232a666fe5f8027ef533219b49e56960e9e803f8023420022334c37749f8094e2346232a666fe5f8037ef53321bd49e56960e9e803f8074e2346210100097d54f8072272c35f48e805c9f8027ef533cd183ee801c9e8fef8054e234659501af80077131a23325e2356f8047e1259501af80077131a23
322a666f2359507d12137c12e802c9e8fef8003600233600f8044e23460a03b7ca2d4af8003420022334c31d4af8005e2356e802c9f8022ae04b2ae04ac92100c0cb21cb210600097b227a22c9c5f8044e2356235ecd3e4ac1c9c5f80456235ef809462b4e2b3a666fcd8b4bc1c9f040cb67c2bb4ac5f807462b4e2b5e2b6ee5
afb32005110010180926006b29292929545de17d079f6729292929c501009009c1cb5c2806cb642802cba4f041e60220fa0a22031b7ab320e8c1c9c5f807462b4e2b5e2b6ee5afb32005110010180926006b29292929545de1260029292929c501008009c1cd554bc1c9f5c506ffcdfa4ab720f80520f7c1f1c9c53e20e000f0
00f0002fe60fcb37473e10e000f000f000f000f000f000f0002fe60fb0cb37473e30e00078c1c9cdfa4aa028fac9cdfa4a5fc9c5f80446cd274b5fc1c92102c0cb21cb210600097a77c9c5f8044e2356cd3d4bc1c9f041e60220fa0a22031b7ab320f2c9c5f809562b5e2b462b4e2b3a6e67cd554bc1c9c5f80456235ef80946
2b4e2b3a666fcd9c4bc1c9e5f040cb772005210098181421009c180fe5f040cb5f2005210098180321009cc5afb32807012000091d20fc06004a09c1d1e5d5f041e60220fa0a22031520f4e154e11d280ac501200009c1e5d518e4c9c5f80b462b4e2b562b5ef804d556235e232a6e67cdab4bc1c97ab3c87cfe983803d61067
afbb200115f041cb4f20fa0a2203f041cb4f20fa0a77032c2008247cfe98200226881d20e015cb7a28dbc97ab3c87cfe983803d61067d50a5f03c5010000faf9c6cb47280206ffcb4f28020eff57faf8c6aa57cb4228037ba847cb4a28037ba94ff041cb4f20fa7023f041cb4f20fa71237cfe9820022688c1d11b7ab320b7c9
cd2846e521e5c606067e23b6fe00280b23230520f4e12100001824d1722b73fae3c62b77e5cd104dfa85c6e602c4c84c21e1c62a666f23fae3c686eae3c6e1f040f681e6e7e040c921e1c62a666f235e1600cb13cb12cb13cb12cb13cb122b7ef5e603018000fe01280a010000fe0228030100012323094d44fae0c66f260029
2929293e908467f1cb57caf54bc32b4c2aeae0c62aeae1c62aeae2c6c9fe0a200ef5fa85c6e6082005cd094ef1c9f1cd464dcd1e4ec9cd464dcd1e4ec9cdf24d3e00cd464dc9f5fae2c6b7200ecdb54dafeae3c6cd1347b34e0000f1c5d5e55f21e1c62a666f2ae603fe022805231600195efae0c6835ffaf7c66f2600292929
2929faf6c64f06000901009809f041cb4f20fa73e1d1c1c9c5f8047e23666fcd804ce5d1c1c9c5f8047e23666fcd104dc1110000c9c5cd7a4e3e01eae3c6af21e4c60612220520fc3e03eaf8c63e00eaf9c6cdd74dc1c9d5e52100981e201620f041cb4f20fa3600231520f41d20efe1d1c9e521f6c6afbe280335180a361321
f7c6afbe280135e1c9e5afeaf6c621f7c63e11be2803341803cd4c4ee1c9e521f6c63e13be2803341820360021f7c63e11be2803341813fa85c6e6042809afeaf7c6eaf6c61803cd4c4ee1c9c5d5e52100980120981e1f1620f041e60220fa0a22031520f41d20ef1620f041e60220fa3e00221520f4e1d1c1c9f3f040cb7f28
15cd2846011e58218dc6cdd545012958219dc6cdd545cda34ef040f681e6e7e040fbc9afeaf6c6eaf7c6cdd74d3e02ea85c6c921ba4ecd804cc904ff000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f40414243
4445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3
c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff000000000000000018244281e724243c3c2424e7814224181814f28181f2141818284f81814f2818ff818181818181fff8888f89f941417fff898989f98181ff0103068c
d87020007ec3d3d3dbc3c37e183c2c2c7e181800101c12101070f060f0c0fed8de18180070c8dedbdb7e1b1b000000ffffff00001c1c1c1c1c1c1c1c7cc6c600c6c67c0006060600060606007c06067cc0c07c007c06067c06067c00c6c6c67c060606007cc0c07c06067c007cc0c07cc6c67c007c060600060606007cc6c67c
c6c67c007cc6c67c06067c00003c46067e663c0078667d647e030b060000001f1f1f1c1c000000fcfcfc1c1c1c1c1c1f1f1f00001c1c1cfcfcfc000000000000000000001818181818001800666644000000000000247e24247e2400143e553c1e553e1462660c183066460078cc61cecccc7800181810000000000004081818
181808042010181818181020005438fe385400000018187e1818000000000000003030200000003c00000000000000000018180003060c183060c0003c666e7666663c0018381818181818003c660e1c38707e007e0c183c06463c000c1c2c4c7e0c0c007e607c0606463c001c20607c66663c007e060e1c181818003c66663c
66663c003c66663e060c380000181800001818000018180018181000060c1830180c060000003c00003c00006030180c183060003c46060c181800183c666e6a6e603c003c66667e666666007c66667c66667c003c62606060623c007c66666666667c007e60607c60607e007e60607c606060003c62606e66663e006666667e
6666660018181818181818000606060606463c00666c7870786c66006060606060607c00fcd6d6d6d6c6c60062727a5e4e4642003c66666666663c007c66667c606060003c66666666663c067c66667c666666003c62703c0e463c007e181818181818006666666666663c006666666666647800c6c6c6d6d6d6fc006666663c
666666006666663c181818007e0e1c3870607e001e18181818181e00406030180c060200781818181818780010386c00000000000000000000007e0000c0c06000000000003c463e66663e00607c666666667c00003c626060623c00063e666666663e00003c667e60623c001e307c3030303000003e6666663e463c607c6666
666666001800181818181800000818181818583060646870786c66001818181818180c0000fcd6d6d6d6c600007c666666666600003c666666663c00007c6666667c6060003e666666663e06006c706060606000003c72381c4e3c00183c181818180c000066666666663e00006666666664780000c6c6d6d6d6fc000066663c
6666660000666666261e463c007e0e1c38707e000e18183018180e0018181818181818187018180c181870000060f29e0c00000010102828444482fe3c62606060621c302400666666663e000c18003c7e603c001866003c067e3e0024003c463e463e003018003c067e3e001818003c067e3e00003c6260623c08181834003c
7e603e0024003c667e603e003018003c7e603c0024001818181818001824001818181800100800181818180024003c667e66660018003c667e6666000c187e607c607e0000007e1b7fd87e003f78d8def8d8df001834003c66663c0024003c6666663c003018003c66663c001824006666663c003018006666663c0066006666
663e463c66003c6666663c006600666666663c00183c626060623c181c3a307c30307e0066663c183c1818003c66666c6666ec0018181818181818180c18003c067e3e000c180018181818000c18003c66663c000c18006666663e003458007c666666001a2c62725a4e4600003c463e663e007e003c6666663c007e00180018
3060663c0000003e303030000000007c0c0c0c0062e468762b43860f62e468762e569f0600180018181818181b366cd86c361b00d86c361b366cd8003458003c067e3e003458003c66663c00023c666e76663c4000023c6e76663c4000007edbded87f00007ed8d8fcd8d8de20103c66667e666634583c66667e666634583c66
6666663c66000000000000000c1830000000000000103810101000007acacaca7a0a0a0a3c4299b5b19d423c3c42b9b5b9b5423cf15b5551510000006600e66666f6061cf666666666f6061c0066763c6e660000007c0c0c0c7e0000001e060e1e360000007e0c0c0c0c0000007c066666660000001c0c0c0c0c0000001e0c06
06060000007e363636360000606e6666667e0000003c0c0c00000000003e0606063e0000607e0606060e0000006c3e66666e0000001c0c0c0c3c0000003e3636361c000000363636367e0000007e6676067e00000066663c0e7e0000003e06363634300000780c0c0c0c000000d6d6d6d6fe0000007c6c6c6cec0000001c0c0c
0c0c0c00003e06060606060000fe6666667e0000007e6676060606000036361c0c0c0c001c323c66663c4c380010386cc682000066f79999ef660000000076dcc8dc76001c36667c66667c6000fe6662606060f80000fe6c6c6c6c48fe6630183066fe00001e386c6c6c380000006c6c6c6c7fc000007e18181818103c183c66
663c183c003c667e66663c00003c6666662466001c3678dcccec78000c1838545438306000107cd6d6d67c103e70607e60703e003c66666666666600007e007e007e000018187e1818007e0030180c1830007e000c1830180c007e00000e1b1b1818181818181818d8d870001818007e0018180000324c00324c0000386c3800
00000000387c380000000000000000001818000000000f18d8703000386c6c6c6c000000386c18307c000000780c380c7800000000fe000000000000f3f040cb7f2803cd28462100811180160600cdc559011e58cdb745012958cdbd453e48e0453e44e041f0fff602e0ff2100983e10010c001e121614223c1520fb091d20f5
f040f691e6f7e0403e01ea85c63e00eafac63e03eaf8c63e00eaf9c6fbc9f040f610e0403e48e045c9f041cb4f20faf040e6efe040c9210081118016cd554bc9d5e568cb25cb25cb25260029545d21a558cb21cb21cb21060009094623666819444de1c57cb52806111000cd554be1c1111000cd554bc9c5fa85c6fe01c4bc57
f8042a472a4f2a5f2a572a666fcd4058c1c9c5fa85c6fe01c4bc57f8042a4f46cd3658c1c9008102810481068108810a810c810e81408242824482468248824a824c824e82808382838483868388838a838c838e83c084c284c484c684c884ca84cc84ce84008602860486068608860a860c860e86408742874487468748874a
874c874e87808882888488868888888a888c888e88c089c289c489c689c889ca89cc89ce89008b028b048b068b088b0a8b0c8b0e8b408c428c448c468c488c4a8c4c8c4e8c808d828d848d868d888d8a8d8c8d8e8dc08ec28ec48ec68ec88eca8ecc8ece8e009002900490069008900a900c900e90409142914491469148914a
914c914e91809282928492869288928a928c928e92c093c293c493c693c893ca93cc93ce93009502950495069508950a950c950e95409642964496469648964a964c964e96f041e60220fa70231b7ab320f3c9f040cb772005210098181321009c180ef040cb5f2005210098180321009c110004c3c55921a0c03600210fc136
002110c136002176c636002177c636002178c636002179c63600217ac63600217bc63600217cc63600217dc63600217ec636002336002180c63600233600c9ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
`

const MODE_HBLANK: number = 0;
const MODE_VBLANK: number = 1;
const MODE_OAMSEARCH: number = 2;
const MODE_PIXELTRANSFER: number = 3;

//PALLETTE
const COLOR1 = 1;
const COLOR2 = 13;
const COLOR3 = 11;
const COLOR4 = 15;

class PPU {

    gameboy: Gameboy;
    frame_complete = false; //after scanline 153 is complete
    scanlineDrawn = false; //to keep track of if scanline was drawn yet

    //LCDC Register
    lcd_control: number = 1;
    window_tilemap_select: number = 0;
    window_display_on: number = 0;
    bg_tiledata_select: number = 0;
    bg_tilemap_select: number = 0;
    sprite_size: number = 0;
    sprite_display: number = 0;
    bg_display: number = 0;

    //STAT Register
    coincidence_flag: number = 0;
    mode_flag: number = 0;
    interrupt_coincidence: number = 0;
    interrupt_oam: number = 0;
    interrupt_vblank: number = 0;
    interrupt_hblank: number = 0;

    //LYC Register
    lyc_compare: number = 0; //used to compare current line to this register

    //Scroll Registers
    scroll_x: number = 0;
    scroll_y: number = 0;

    //Palette Registers
    palette_bg: number = 0;
    palette_sprite_0: number = 0;
    palette_sprite_1: number = 0;

    //Window Registers
    window_y: number = 0;
    window_x: number = 0;

    //color gameboy
    cgb_bg_palettes: Buffer; //64 bytes
    cgb_bg_pal_index: number = 0;
    cgb_bg_pal_auto_increment: number = 0;
    cgb_sprite_palettes: Buffer; //64 bytes
    cgb_sprite_pal_index: number = 0;
    cgb_sprite_pal_auto_increment: number = 0;
    hdma_source_high: number = 0;
    hdma_source_low: number = 0;
    hdma_source_address: number = 0;
    hdma_dest_address: number = 0;
    hdma_dest_high: number = 0;
    hdma_dest_low: number = 0;
    hdma_control: number = 0; //what was written to FF55
    hdma_mode: number = 0; //general hdma (0) or h-blank hdma (1)
    hdma_length: number = 0; //how many bytes are we transferring
    hdma_current_byte: number = 0; //what byte are we up to
    hdma_in_progress: boolean = false; //is an hdma h-blank mode currently in progress
    colorize_gb_games: boolean = false; //for colorizing GB games in GBC Mode

    //debugging
    toggleBG: boolean = true;
    toggleWindow: boolean = true;
    toggleSprites: boolean = true;
    debugScrollX: number = 0;
    debugScrollY: number = 0;



    /*
                        20 clks        43 clks      51 clks
                    |            |                |         |
        144 lines   | OAM Search | Pixel Transfer | H=Blank |
                    |            |                |         |
                    -----------------------------------------
        10 lines    |                V-Blank                |
        
    */
    //  Mode 0 H-blank period        - 51 cycles
    //  Mode 1 V-blank period        - 1140 cycles
    //  Mode 2 Reading OAM           - 20 cycles
    //  Mode 3 Pixel Transfer        - 43 cycles
    //  Single Line - 114 cycles
    //  Full Frame - 17556 cycles
    //  V-blank - lines 145 to 154
    mode = 0; //current mode ppu is in
    tick = 0; //determine what cycle within a single line
    line = 0; //determine what line the ppu is up toggleBG

    constructor(gameboy: Gameboy) {
        this.gameboy = gameboy;
        this.cgb_bg_palettes = Buffer.create(64);
        this.cgb_sprite_palettes = Buffer.create(64);
    }

    clock(cycles: number) {


        //increment tick and line
        //cpu is in cycles of 4 but ppu
        //is in machine cycles (4 cpu cycles = 1 machine cycle)
        //so adjust by dividing by 4
        this.tick += (cycles / 4) + 1;
        let newline = false;
        if (this.tick >= 114) {
            this.line++;
            if (this.line == 154) {
                this.line = 0;
                this.frame_complete = true;

                //for logging
                this.gameboy.cpu.frameNumber++;
            }

            //coincidence new implementation
            //fixes donkey kong and donkey kong land
            //fixes batman spinning logo
            //fixes castlevania 2 level select
            //fixes ghostbusters 2
            this.coincidence_flag = 0;
            if (this.lcd_control == 1) {
                if (this.line == this.lyc_compare) {
                    this.coincidence_flag = 1;
                }
                if (this.coincidence_flag == 1) {
                    if (this.interrupt_coincidence) {
                        this.gameboy.cpu.request_interrupt_lcd();
                    }
                }
            }



            this.tick = this.tick - 114;
            newline = true;
            this.scanlineDrawn = false;
        }
        if (newline) {

            //draw all sprites
            if (this.line == 144 && this.lcd_control == 1) {
                if (enableDrawing) {
                    this.drawSprites();
                }
                // if (!this.gameboy.memory.color_gb)
                // else
                //     this.drawSpritesColor();
            }
        }

        //determine mode
        if (this.line >= 144) {
            this.mode = MODE_VBLANK;

            //only generate interrupts if lcd is on
            if (this.lcd_control == 1) {
                if (this.line == 144 && newline) {
                    this.gameboy.cpu.request_interrupt_vblank();

                    //for debugging
                    this.debugScrollX = this.scroll_x;
                    this.debugScrollY = this.scroll_y

                    //todo - move this out of this
                    //immediate if statement?
                    if (this.interrupt_vblank) {
                        this.gameboy.cpu.request_interrupt_lcd();

                    }
                }
            }

        }
        else {
            if (this.tick >= 63) {
                this.mode = MODE_HBLANK;

                if (this.lcd_control == 1) {
                    //draw the scanline at the beginning of
                    //h-blank rather than the beginning of
                    //pixel transfer otherwise the status bar
                    //in super mario land flickers
                    if (this.scanlineDrawn == false) {

                        //BG and Window Layers
                        if (this.gameboy.memory.color_gb) {
                            // if (true) {
                            //     this.drawScanlineColor(true);
                            //     if (this.window_display_on)
                            //         this.drawScanlineColor(false);
                            // }
                        } else {
                            if (enableDrawing) {
                                this.drawScanline(true);
                                if (this.window_display_on)
                                    this.drawScanline(false);
                            }
                        }

                        this.scanlineDrawn = true;

                        //color gameboy h-blank
                        if (this.hdma_in_progress)
                            this.HDMA_Run_Hblank();

                        if (this.interrupt_hblank) {
                            this.gameboy.cpu.request_interrupt_lcd();
                        }
                    }

                }
            }
            else if (this.tick >= 20) {
                this.mode = MODE_PIXELTRANSFER;
            }
            else {
                this.mode = MODE_OAMSEARCH;

                if (this.lcd_control == 1) {
                    if (this.interrupt_oam) {
                        this.gameboy.cpu.request_interrupt_lcd();
                    }
                }
            }
        }

    }



    readRegister(address: number): number {

        switch (address) {
            case 0xFF40:
                return this.assembleLCDCRegister();
            case 0xFF41:
                return this.assembleSTATRegister();
            case 0xFF42:
                return this.scroll_y;
            case 0xFF43:
                return this.scroll_x;
            case 0xFF44:
                //apparently Line 153 should return 0, weird
                //fixes GBC Aladdin and Atlantis
                //http://forums.nesdev.com/viewtopic.php?f=20&t=13727
                if (this.line == 153)
                    return 0;
                else
                    return this.line;
            case 0xFF45:
                return this.lyc_compare;
            case 0xFF47:
                return this.palette_bg;
            case 0xFF48:
                return this.palette_sprite_0;
            case 0xFF49:
                return this.palette_sprite_1;
            case 0xFF4A:
                return this.window_y;
            case 0xFF4B:
                return this.window_x;
            case 0xFF51:
                return this.hdma_source_high;
            case 0xFF52:
                return this.hdma_source_low;
            case 0xFF53:
                return this.hdma_dest_high;
            case 0xFF54:
                return this.hdma_dest_low;
            case 0xFF55:
                return this.HDMA_Read_Control();
            case 0xFF69:
                return this.cgb_bg_palettes[this.cgb_bg_pal_index];
            case 0xFF6B:
                return this.cgb_sprite_palettes[this.cgb_sprite_pal_index];
        }
        return this.gameboy.memory.ram[address];

    }


    writeRegister(address: number, value: number) {

        value = value & 0xff;

        switch (address) {
            case 0xFF40:
                this.parseLCDCRegister(value);
                break;
            case 0xFF41:
                this.parseSTATRegister(value);
                break;
            case 0xFF42:
                this.scroll_y = value;
                break;
            case 0xFF43:
                this.scroll_x = value;
                break;
            case 0xFF44:
                this.line = 0;
                break;
            case 0xFF45:
                this.lyc_compare = value;
                break;
            case 0xFF46:
                this.gameboy.ppu.OAM_DMA(value);
                break;
            case 0xFF47:
                this.palette_bg = value;
                break;
            case 0xFF48:
                this.palette_sprite_0 = value;
                break;
            case 0xFF49:
                this.palette_sprite_1 = value;
                break;
            case 0xFF4A:
                this.window_y = value;
                break;
            case 0xFF4B:
                this.window_x = value;
                break;
            case 0xFF51:
                this.hdma_source_high = value;
                break;
            case 0xFF52:
                this.hdma_source_low = value;
                break;
            case 0xFF53:
                this.hdma_dest_high = value;
                break;
            case 0xFF54:
                this.hdma_dest_low = value;
                break;
            case 0xFF55:
                this.HDMA_Write_Control(value);
                break;
            case 0xFF68:
                this.cgb_bg_pal_index = value & 0x3F; //first 6 bits
                this.cgb_bg_pal_auto_increment = BitHelper.getBit(value, 7); //bit 7
                break;
            case 0xFF69:
                this.cgb_bg_palettes[this.cgb_bg_pal_index] = value;
                if (this.cgb_bg_pal_auto_increment) {
                    this.cgb_bg_pal_index++;
                    if (this.cgb_bg_pal_index == 64)
                        this.cgb_bg_pal_index = 0;
                }
                break;
            case 0xFF6A:
                this.cgb_sprite_pal_index = value & 0x3F; //first 6 bits
                this.cgb_sprite_pal_auto_increment = BitHelper.getBit(value, 7); //bit 7
                break;
            case 0xFF6B:
                this.cgb_sprite_palettes[this.cgb_sprite_pal_index] = value;
                if (this.cgb_sprite_pal_auto_increment) {
                    this.cgb_sprite_pal_index++;
                    if (this.cgb_sprite_pal_index == 64)
                        this.cgb_sprite_pal_index = 0;
                }
                break;

        }
        this.gameboy.memory.ram[address] = value;

    }

    //TODO - fix this
    HDMA_Write_Control(value: number) {
        this.hdma_control = value;

        //writing 0 to bit 7 shuts off in progress hblank hdma
        if (this.hdma_in_progress && BitHelper.getBit(value, 7) == 0) {
            this.hdma_in_progress = false;
            return;
        }

        let amount = value & 127; //lower 7 bits
        this.hdma_mode = BitHelper.getBit(value, 7); //last bit
        this.hdma_length = (amount + 1) * 0x10;

        //lower four bits ignored
        this.hdma_source_address = (this.hdma_source_high << 8) + (this.hdma_source_low & 0xF0);
        this.hdma_dest_address = 0x8000 + ((this.hdma_dest_high & 0x1F) << 8) + (this.hdma_dest_low & 0xF0);


        //General HDMA
        if (this.hdma_mode == 0) {
            for (let i = 0; i < this.hdma_length; i++) {
                let byte = this.gameboy.memory.read(this.hdma_source_address + i);
                this.gameboy.memory.write(this.hdma_dest_address + i, byte);
            }

            //adjust machine cycles?
            this.gameboy.cpu.hdma_cycles = this.hdma_length;
            // this.tick += (this.hdma_length);
            // if (this.tick>114){
            //     this.line += Math.floor(this.tick/114);
            //     this.tick = this.tick % 114;
            // }

        }
        //H-Blank HDMA
        if (this.hdma_mode == 1) {
            this.hdma_in_progress = true;
            this.hdma_current_byte = 0;
        }

    }

    HDMA_Run_Hblank() {
        //transfer 16 bytes at a time
        for (let i = 0; i < 0x10; i++) {
            let byte = this.gameboy.memory.read(this.hdma_source_address + this.hdma_current_byte + i);
            this.gameboy.memory.write(this.hdma_dest_address + this.hdma_current_byte + i, byte);
        }

        this.hdma_current_byte += 0x10;

        //adjust machine cycles?
        this.gameboy.cpu.hdma_cycles = 16;

        //once we have transferred all the bytes
        //then we turn off hblank hdma
        if (this.hdma_current_byte >= this.hdma_length) {
            this.hdma_in_progress = false;
        }
    }

    HDMA_Read_Control(): number {

        if (this.hdma_in_progress) {
            let remaining_length = ((this.hdma_length - this.hdma_current_byte) / 0x10) - 1;

            if (remaining_length == -1)
                remaining_length = 0xFF;
            else {
                //bit 7 always returns 0 if transfer is still active
                remaining_length = BitHelper.setBit(remaining_length, 7, 0);
            }

            return remaining_length;
        }
        else
            return 0xFF;

    }

    parseLCDCRegister(value: number) {
        this.lcd_control = BitHelper.getBit(value, 7);

        if (this.lcd_control == 0) {
            //shut off LCD related interrupts
            //fix for sml2 tree level
            this.gameboy.cpu.IF = BitHelper.setBit(this.gameboy.cpu.IF, 0, 0);
            this.gameboy.cpu.IF = BitHelper.setBit(this.gameboy.cpu.IF, 1, 0);

            this.tick = 0;
        }

        this.window_tilemap_select = BitHelper.getBit(value, 6);
        this.window_display_on = BitHelper.getBit(value, 5);
        this.bg_tiledata_select = BitHelper.getBit(value, 4);
        this.bg_tilemap_select = BitHelper.getBit(value, 3);
        this.sprite_size = BitHelper.getBit(value, 2);
        this.sprite_display = BitHelper.getBit(value, 1);
        this.bg_display = BitHelper.getBit(value, 0);
    }

    assembleLCDCRegister() {
        let value = 0;
        value = BitHelper.setBit(value, 7, this.lcd_control);
        value = BitHelper.setBit(value, 6, this.window_tilemap_select);
        value = BitHelper.setBit(value, 5, this.window_display_on);
        value = BitHelper.setBit(value, 4, this.bg_tiledata_select);
        value = BitHelper.setBit(value, 3, this.bg_tilemap_select);
        value = BitHelper.setBit(value, 2, this.sprite_size);
        value = BitHelper.setBit(value, 1, this.sprite_display);
        value = BitHelper.setBit(value, 0, this.bg_display);
        return value;
    }

    parseSTATRegister(value: number) {
        this.interrupt_coincidence = BitHelper.getBit(value, 6);
        this.interrupt_oam = BitHelper.getBit(value, 5);
        this.interrupt_vblank = BitHelper.getBit(value, 4);
        this.interrupt_hblank = BitHelper.getBit(value, 3);
    }

    assembleSTATRegister() {

        // coincidence_flag: number = 0;
        // mode_flag: number = 0;

        let value = 0;
        value = BitHelper.setBit(value, 2, this.coincidence_flag);

        let bit1 = 0;
        let bit0 = 0;

        //if LCD is off return vblank
        if (this.lcd_control == 0)
            this.mode == MODE_VBLANK;

        if (this.mode == MODE_HBLANK) {
            bit0 = 0;
            bit1 = 0;
        }
        if (this.mode == MODE_VBLANK) {
            bit0 = 1;
            bit1 = 0;
        }
        if (this.mode == MODE_OAMSEARCH) {
            bit0 = 0;
            bit1 = 1;
        }
        if (this.mode == MODE_PIXELTRANSFER) {
            bit0 = 1;
            bit1 = 1;
        }
        value = BitHelper.setBit(value, 1, bit1);
        value = BitHelper.setBit(value, 0, bit0);

        //always set the top 2 bits?
        value |= 192;

        return value;
    }

    //takes in a parameter if we are drawing
    //either the background or window layer
    drawScanline(bg_layer: boolean) {
        if (this.toggleBG == false && bg_layer)
            return;
        if (this.toggleWindow == false && !bg_layer)
            return;

        let last_map_pointer = -1;
        let last_byte1 = 0;
        let last_byte2 = 0;

        //Scroll Y
        let adjustedLine = this.line + this.scroll_y;
        if (bg_layer) {
            if (adjustedLine > 255)
                adjustedLine = adjustedLine - 256;
        }
        //Window Layer
        else {
            adjustedLine = this.line - this.window_y;
            if (adjustedLine < 0)
                return;
        }


        for (let xcood = 0; xcood < 160; xcood++) {

            //Scroll X
            let pixel_coordinate = xcood + this.scroll_x;
            if (pixel_coordinate > 255)
                pixel_coordinate = pixel_coordinate - 256;

            //Window Layer
            if (!bg_layer) {
                pixel_coordinate = xcood - this.window_x + 7;

                //window starts farther to the right of this pixel
                if (this.window_x - 7 > xcood)
                    continue;
            }

            let map_pointer = 0x9800 + (Math.floor(adjustedLine / 8) * 32) + Math.floor(pixel_coordinate / 8);
            let tile_pointer = 0;

            let byte1 = 0;
            let byte2 = 0;
            //so that we can save on the number of memory reads
            if (last_map_pointer != map_pointer) {
                if (bg_layer) {
                    if (this.bg_tilemap_select == 1)
                        map_pointer += 0x400;
                }
                //Window Layer
                else {
                    if (this.window_tilemap_select == 1)
                        map_pointer += 0x400;
                }

                let tile = this.gameboy.memory.read(map_pointer);
                tile_pointer = 0x8000 + (tile * 16) + ((adjustedLine % 8) * 2);

                //if bg_tiledata_select is 0 then
                //the tile indexes are signed 
                //meaning -128 to 127
                if (this.bg_tiledata_select == 0) {
                    tile_pointer += 0x1000;
                    if (tile > 127) {
                        tile_pointer -= 0x1000;
                    }
                }
                byte1 = this.gameboy.memory.read(tile_pointer);
                byte2 = this.gameboy.memory.read(tile_pointer + 1);

                last_map_pointer = map_pointer;
                last_byte1 = byte1;
                last_byte2 = byte2;
            }
            else {
                byte1 = last_byte1;
                byte2 = last_byte2;
            }


            let xmod = pixel_coordinate % 8;

            let bit1 = BitHelper.getBit(byte1, 7 - xmod);
            let bit2 = BitHelper.getBit(byte2, 7 - xmod);
            let color = bit1 + (bit2 * 2);
            let realcolor = 0;

            //get color from palette
            if (color == 0) {
                bit1 = BitHelper.getBit(this.palette_bg, 0);
                bit2 = BitHelper.getBit(this.palette_bg, 1);
                color = bit1 + (bit2 * 2);
            }
            else if (color == 1) {
                bit1 = BitHelper.getBit(this.palette_bg, 2);
                bit2 = BitHelper.getBit(this.palette_bg, 3);
                color = bit1 + (bit2 * 2);
            }
            else if (color == 2) {
                bit1 = BitHelper.getBit(this.palette_bg, 4);
                bit2 = BitHelper.getBit(this.palette_bg, 5);
                color = bit1 + (bit2 * 2);
            }
            else {
                bit1 = BitHelper.getBit(this.palette_bg, 6);
                bit2 = BitHelper.getBit(this.palette_bg, 7);
                color = bit1 + (bit2 * 2);
            }

            if (color == 0) realcolor = COLOR1;
            if (color == 1) realcolor = COLOR2;
            if (color == 2) realcolor = COLOR3;
            if (color == 3) realcolor = COLOR4;

            // this.gameboy.SCREEN_MAIN.setPixel(xcood, this.line, new Color(realcolor, realcolor, realcolor), false);

            //scale it to the screen 120 pixels vs 144 pixels            
            let drawY = this.line * 0.833;
            scene.backgroundImage().setPixel(xcood, drawY, realcolor);
        }

    }

    //in order to get direct access to vram 
    //without going through the memory class
    readVRAM(address: number, bank: number): number {
        let real_address = address - 0x8000 + bank * 0x2000;
        return this.gameboy.memory.vram[real_address];
    }

    OAM_DMA(address: number) {

        let pointer = 0xFE00;
        let start_address = address * 256;
        for (let i = 0; i < 160; i++) {
            let value = this.gameboy.memory.read(start_address + i);
            this.gameboy.memory.write(pointer + i, value);
        }

    }


    drawSprites() {
        if (this.toggleSprites == false)
            return;

        let pointer = 0xFE00;
        for (let i = 0; i < 40; i++) {
            let byteY = this.gameboy.memory.read(pointer);
            let byteX = this.gameboy.memory.read(pointer + 1);
            let byteTile = this.gameboy.memory.read(pointer + 2);
            let byteFlags = this.gameboy.memory.read(pointer + 3);
            let bitPriority = BitHelper.getBit(byteFlags, 7);
            let bitYFlip = BitHelper.getBit(byteFlags, 6);
            let bitXFlip = BitHelper.getBit(byteFlags, 5);
            let bitPalette = BitHelper.getBit(byteFlags, 4);

            pointer += 4;

            let tile_pointer = 0x8000 + (byteTile * 16);
            if (this.sprite_size == 1)
                tile_pointer = 0x8000 + ((byteTile & 0xFE) * 16);
            let ymax = 8;

            if (this.sprite_size == 1)
                ymax = 16;
            for (let y = 0; y < ymax; y++) {


                let byte1 = this.gameboy.memory.read(tile_pointer);
                let byte2 = this.gameboy.memory.read(tile_pointer + 1);

                tile_pointer += 2

                for (let x = 0; x < 8; x++) {
                    let flipXoffset = 0
                    if (bitXFlip) {
                        flipXoffset = 7 - (x * 2);
                    }

                    let flipYoffset = 0
                    if (bitYFlip) {
                        if (this.sprite_size == 1)
                            flipYoffset = 15 - (y * 2);
                        else
                            flipYoffset = 7 - (y * 2);
                    }

                    let bit1 = BitHelper.getBit(byte1, 7 - x);
                    let bit2 = BitHelper.getBit(byte2, 7 - x);
                    let color = bit1 + (bit2 * 2);
                    let originalColor = color;
                    let realcolor = 0;
                    let palette = this.palette_sprite_0;
                    if (bitPalette == 1)
                        palette = this.palette_sprite_1;

                    //get color from palette


                    if (color == 1) {
                        bit1 = BitHelper.getBit(palette, 2);
                        bit2 = BitHelper.getBit(palette, 3);
                        color = bit1 + (bit2 * 2);
                    }
                    else if (color == 2) {
                        bit1 = BitHelper.getBit(palette, 4);
                        bit2 = BitHelper.getBit(palette, 5);
                        color = bit1 + (bit2 * 2);
                    }
                    else if (color == 3) {
                        bit1 = BitHelper.getBit(palette, 6);
                        bit2 = BitHelper.getBit(palette, 7);
                        color = bit1 + (bit2 * 2);
                    }

                    if (color == 0) realcolor = COLOR1;
                    if (color == 1) realcolor = COLOR2;
                    if (color == 2) realcolor = COLOR3;
                    if (color == 3) realcolor = COLOR4;

                    let transparent = false;
                    if (originalColor == 0)
                        transparent = true;


                    //TODO - make sure I don't go off screen
                    //scale it to the screen 120 pixels vs 144 pixels    
                    if (!transparent) {
                        let drawY = (y + byteY - 16 + flipYoffset) * 0.833;
                        scene.backgroundImage().setPixel(
                            x + byteX - 8 + flipXoffset,
                            drawY,
                            realcolor);
                    }
                }
            }
        }
    }

}

class Memory {

    public ram: Buffer;
    gameboy: Gameboy;


    //for performance
    //amazingly accessing this.gameboy.cartridge.prgBanks is slower than
    //this.prgBanksCopy seemingly because it needs to access a seperate object
    prgData: Buffer;
    externalRam: Buffer;
    joypadRegister: number = 0xFF;
    cartridge_type: number = 0;
    boot_finished = true; //after boot code runs set this to true

    //Mappers
    prgBank = 1;
    prgBankLower = 0; //MBC5
    prgBankUpper = 0; //MBC5
    prgBankOffset = 0;
    externalRamBank = 0;
    externalRamBankOffset = 0;
    externalRamMode = 0;
    externalRamEnabled = false;

    //Serial Cable
    serialData: number = 0;
    serialControl: number = 0;

    //Gameboy Color
    color_gb: boolean = false; //gameboy color title
    color_only: boolean = false; //if it only supports color gameboy
    vram_bank: number = 0;
    vram: Buffer;
    wram_bank: number = 1;
    wram: Buffer;


    constructor(gameboy: Gameboy) {
        this.gameboy = gameboy;

        //full address space
        this.ram = Buffer.create(0xFFFF);

        /* GAMEBOY COLOR */
        // double the VRAM of GB
        this.vram = Buffer.create(0x4000);
        // 7 banks switchable
        this.wram = Buffer.create(0x7000);
    }

    read(address: number): number {


        //Cartridge
        if (address < 0x8000) {
            let real_address = address;

            //ROM
            if (this.cartridge_type == 0) {
                return this.prgData[real_address];
            }
            //MBC1
            else if (this.cartridge_type < 4) {

                if (address >= 0x4000) {
                    real_address += this.prgBankOffset;
                }

            }
            //MBC2
            else if (this.cartridge_type < 7) {

                if (address >= 0x4000) {
                    real_address += this.prgBankOffset;
                }

            }
            //MBC3
            else if (this.cartridge_type >= 15 &&
                this.cartridge_type <= 19) {

                if (address >= 0x4000) {
                    real_address += this.prgBankOffset;
                }
            }
            //MBC5
            else if (this.cartridge_type >= 25 &&
                this.cartridge_type <= 30) {

                if (address >= 0x4000) {
                    real_address += this.prgBankOffset;
                }
            }

            return this.prgData[real_address];
        }
        else {

            let real_address = address;

            //Video RAM
            if (address >= 0x8000 && address <= 0x9FFF) {
                //Perf: 75 percent of non cartridge reads go here
                if (this.color_gb) {
                    //Intercept VRAM reads here
                    real_address = address - 0x8000 + (this.vram_bank * 0x2000);
                    return this.vram[real_address];
                }
            }
            // High RAM (HRAM)
            else if (address >= 0xFF80 && address <= 0xFFFE) {
                //Perf: 25 percent of non cartridge reads go here
            }
            //External RAM
            else if (address >= 0xA000 && address <= 0xBFFF) {
                let eRamAddress = address - 0xA000 + this.externalRamBankOffset;
                return this.externalRam[eRamAddress];
            }
            //Work RAM
            else if (address >= 0xC000 && address <= 0xDFFF) {
                if (this.color_gb) {
                    //Intercept WRAM reads here
                    if (address >= 0xD000) {
                        real_address = address - 0xD000 + ((this.wram_bank - 1) * 0x1000);
                        return this.wram[real_address];
                    }
                }
            }
            //Mirror of Work RAM
            else if (address >= 0xE000 && address <= 0xFDFF) {
                real_address -= 0x2000;
            }
            //OAM
            else if (address >= 0xFE00 && address <= 0xFE9F) {

            }
            //Not Usable
            else if (address >= 0xFEA0 && address <= 0xFEFF) {

            }
            // I/0 Registers
            else if (address >= 0xFF00 && address <= 0xFF7F) {
                //JOYPAD
                if (address == 0xFF00) {
                    let values = 0xFF;

                    //P14
                    if (BitHelper.getBit(this.joypadRegister, 5)) {
                        //TODO
                        if (controllerRight) values = BitHelper.setBit(values, 0, 0);
                        if (controllerLeft) values = BitHelper.setBit(values, 1, 0);
                        if (controllerUp) values = BitHelper.setBit(values, 2, 0);
                        if (controllerDown) values = BitHelper.setBit(values, 3, 0);

                        return values;
                    }
                    //P15
                    else if (BitHelper.getBit(this.joypadRegister, 4)) {
                        //TODO
                        if (controllerA) {
                            values = BitHelper.setBit(values, 0, 0);
                        }
                        if (controllerB) values = BitHelper.setBit(values, 1, 0);

                        //for some reason the start button wasn't working
                        //until I added a counter for it to get released
                        if (controllerStart) {
                            values = BitHelper.setBit(values, 3, 0);
                            controllerStartCounter--;
                            if (controllerStartCounter == 0)
                            {
                                controllerStart = false;
                            }
                        }

                        return values;
                    }
                    else {
                        return 0xFF;
                    }

                }

                //TIMERS
                if (address == 0xFF04) {
                    return this.gameboy.cpu.TIMER_DIV;
                    // return Math.floor(Math.random() * Math.floor(256));// this.gameboy.cpu.TIMER_DIV;
                }
                if (address == 0xFF05) return this.gameboy.cpu.TIMER_TIMA;
                if (address == 0xFF06) return this.gameboy.cpu.TIMER_TMA;
                if (address == 0xFF07) return this.gameboy.cpu.TIMER_TAC;

                //PPU
                if (address >= 0xFF40 && address <= 0xFF4B) {
                    return this.gameboy.ppu.readRegister(address);
                }

                //APU
                if (address >= 0xFF10 && address <= 0xFF3F) {
                    // return this.gameboy.apu.readRegister(address);
                }

                //IF Interrupt Register
                if (address == 0xFF0F) return this.gameboy.cpu.IF;

                //Color Gameboy
                if (this.color_gb) {

                    //Background Pallete
                    if (address == 0xFF68) {
                        return this.gameboy.ppu.readRegister(address);
                    }
                    //Background Pallete
                    if (address == 0xFF69) {
                        return this.gameboy.ppu.readRegister(address);
                    }
                    //Sprite Pallete
                    if (address == 0xFF6A) {
                        return this.gameboy.ppu.readRegister(address);
                    }
                    //Sprite Pallete
                    if (address == 0xFF6B) {
                        return this.gameboy.ppu.readRegister(address);
                    }
                    //VRAM Bank
                    if (address == 0xFF4F) {
                        let color = 1;
                    }
                    //VRAM DMA
                    if (address >= 0xFF51 && address <= 0xFF55) {
                        return this.gameboy.ppu.readRegister(address);
                    }
                    //Speed Mode
                    if (address == 0xFF4D) {
                        let color = 1;
                    }
                    //VRAM Bank
                    if (address == 0xFF4F) {
                        let currentBank = 0xFF;
                        if (this.vram_bank == 0)
                            currentBank = BitHelper.setBit(currentBank, 0, 0);
                        return currentBank;
                    }
                    //Infrared Port
                    if (address == 0xFF56) {
                        let color = 1;
                    }
                    //WRAM Bank
                    if (address == 0xFF70) {
                        let color = 1;
                    }
                }


            }
            //Enable Interrupts
            else if (address == 0xFFFF) {
                return this.gameboy.cpu.IE;
            }

            return this.ram[real_address];
        }

    }



    write(address: number, value: number) {

        value = value & 0xff;

        //Cartridge
        if (address < 0x8000) {
            let real_address = address;

            //MBC1
            if (this.cartridge_type == 1 ||
                this.cartridge_type == 2 ||
                this.cartridge_type == 3) {

                //Enable RAM
                if (address >= 0x0000 && address <= 0x1FFF) {
                    this.externalRamEnabled = ((value & 0x0F) == 0xA)
                }
                //ROM Bank Select
                if (address >= 0x2000 && address <= 0x3FFF) {
                    if (value == 0) {
                        value = 1;
                    }
                    this.prgBank = (this.prgBank & 0xE0) | (value & 0x1F);
                    this.prgBankOffset = 0x4000 * (this.prgBank - 1) % this.prgData.length;
                }
                // RAM Bank Select
                if (address >= 0x4000 && address <= 0x5FFF) {
                    if (this.externalRamMode == 0) {
                        this.prgBank = (this.prgBank & 0x1F) | (value << 5);
                        this.prgBankOffset = 0x4000 * (this.prgBank - 1);
                    }
                    else {
                        this.externalRamBank = value;
                        this.externalRamBankOffset = 0x2000 * this.externalRamBank;
                    }

                }
                // ROM or RAM Mode Select
                // Needed for Large Carts (up to 32KByte RAM, 512KByte ROM)
                if (address >= 0x6000 && address <= 0x7FFF) {

                    // 16/8 Rom/Ram Mode
                    if (value == 1) {
                        this.externalRamMode = 1;
                    }
                    // 4/32 Rom/Ram Mode
                    else {
                        this.externalRamMode = 0;
                    }
                }

            }

            //MBC2
            if (this.cartridge_type == 5 ||
                this.cartridge_type == 6) {

                //Enable RAM
                if (address >= 0x0000 && address <= 0x1FFF) {
                    this.externalRamEnabled = ((value & 0x0F) == 0xA)
                }
                //ROM Bank Select
                if (address >= 0x2000 && address <= 0x3FFF) {
                    if (value == 0) {
                        value = 1;
                    }
                    this.prgBank = value & 0xF;
                    this.prgBankOffset = 0x4000 * (this.prgBank - 1) % this.prgData.length;
                }
            }

            //MBC3
            if (this.cartridge_type >= 15 &&
                this.cartridge_type <= 19) {

                //Enable RAM
                if (address >= 0x0000 && address <= 0x1FFF) {
                    this.externalRamEnabled = ((value & 0x0F) == 0xA)
                }
                //ROM Bank Select
                if (address >= 0x2000 && address <= 0x3FFF) {
                    if (value == 0) {
                        value = 1;
                    }
                    this.prgBank = value & 0x7F;
                    this.prgBankOffset = 0x4000 * (this.prgBank - 1) % this.prgData.length;
                }
                // RAM Bank Select
                if (address >= 0x4000 && address <= 0x5FFF) {
                    if (value < 8) {
                        this.externalRamBank = value;
                        this.externalRamBankOffset = 0x2000 * this.externalRamBank;
                    }
                }
            }

            //MBC5
            if (this.cartridge_type >= 25 &&
                this.cartridge_type <= 30) {

                //Enable RAM
                if (address >= 0x0000 && address <= 0x1FFF) {
                    this.externalRamEnabled = ((value & 0x0F) == 0xA)
                }
                //ROM Bank Select
                if (address >= 0x2000 && address <= 0x2FFF) {
                    this.prgBankLower = value;
                    this.prgBank = this.prgBankUpper + this.prgBankLower;
                    this.prgBankOffset = 0x4000 * (this.prgBank - 1);
                }
                //ROM Bank Select Upper Bit
                if (address >= 0x3000 && address <= 0x3FFF) {
                    let lowerbit = BitHelper.getBit(value, 0);
                    this.prgBankUpper = (256 * lowerbit);
                    this.prgBank = this.prgBankUpper + this.prgBankLower;
                    this.prgBankOffset = 0x4000 * (this.prgBank - 1);
                }
                // RAM Bank Select
                if (address >= 0x4000 && address <= 0x5FFF) {
                    if (value < 8) {
                        this.externalRamBank = value;
                        this.externalRamBankOffset = 0x2000 * this.externalRamBank;
                    }
                }
            }

            //don't allow writing to the cartridge
            // this.prgData[real_address] = value;
            return;
        }
        else {
            let real_address = address;

            //Video RAM
            if (address >= 0x8000 && address <= 0x9FFF) {
                if (this.color_gb) {
                    //Intercept VRAM writes here
                    real_address = address - 0x8000 + (this.vram_bank * 0x2000);
                    this.vram[real_address] = value;
                    return;
                }
            }
            //External RAM
            else if (address >= 0xA000 && address <= 0xBFFF) {

                //MBC1
                if (this.cartridge_type == 1 ||
                    this.cartridge_type == 2 ||
                    this.cartridge_type == 3 ||
                    this.cartridge_type == 5 ||
                    this.cartridge_type == 6
                ) {
                    if (!this.externalRamEnabled)
                        return;
                }
                let eRamAddress = address - 0xA000 + this.externalRamBankOffset;
                this.externalRam[eRamAddress] = value;
                return;

            }
            //Work RAM
            else if (address >= 0xC000 && address <= 0xDFFF) {
                if (this.color_gb) {
                    //Intercept WRAM writes here
                    if (address >= 0xD000) {
                        real_address = address - 0xD000 + ((this.wram_bank - 1) * 0x1000);
                        this.wram[real_address] = value;
                    }
                }
            }
            //Mirror of Work RAM
            else if (address >= 0xE000 && address <= 0xFDFF) {
                real_address -= 0x2000;
            }
            //OAM
            else if (address >= 0xFE00 && address <= 0xFE9F) {

            }
            //Not Usable
            else if (address >= 0xFEA0 && address <= 0xFEFF) {

            }
            // I/0 Registers
            else if (address >= 0xFF00 && address <= 0xFF7F) {

                //JOYPAD
                if (address == 0xFF00) this.joypadRegister = value;

                //SERIAL CABLE
                //if (real_address == 0xFF01) console.log('Serial Write FF01: ' + String.fromCharCode(value));

                //TIMERS
                if (address == 0xFF04) {
                    this.gameboy.cpu.TIMER_DIV = 0;
                }
                if (address == 0xFF05) {
                    this.gameboy.cpu.TIMER_TIMA = value;
                }
                if (address == 0xFF06) {
                    this.gameboy.cpu.TIMER_TMA = value;
                }
                if (address == 0xFF07) {
                    this.gameboy.cpu.TIMER_TAC = 0xF8 | value;
                    if (BitHelper.getBit(this.gameboy.cpu.TIMER_TAC, 2) == 1)
                        this.gameboy.cpu.timerEnabled = true;
                    else
                        this.gameboy.cpu.timerEnabled = false;
                    let clock_select = value & 0x03;
                    if (clock_select == 0) this.gameboy.cpu.timerSpeed = 1024;
                    if (clock_select == 1) this.gameboy.cpu.timerSpeed = 16;
                    if (clock_select == 2) this.gameboy.cpu.timerSpeed = 64;
                    if (clock_select == 3) this.gameboy.cpu.timerSpeed = 256;
                    this.gameboy.cpu.main_clock_counter = this.gameboy.cpu.timerSpeed;
                }

                //PPU
                if (address >= 0xFF40 && address <= 0xFF4B) {
                    this.gameboy.ppu.writeRegister(address, value);
                }

                //APU
                if (address >= 0xFF10 && address <= 0xFF3F) {
                    // this.gameboy.apu.writeRegister(address, value);
                }

                //IF Interrupt Register
                if (address == 0xFF0F) {
                    this.gameboy.cpu.IF = value;
                    return;
                }

                // Disable Boot Room
                if (address == 0xFF50) {
                    if (this.boot_finished == false) {
                        //finish boot
                        for (let i = 0; i < this.gameboy.cartridge.pre_boot_page.length; i++)
                            this.prgData[i] = this.gameboy.cartridge.pre_boot_page[i];

                        this.boot_finished = true;
                    }
                }

                //Color Gameboy
                if (this.color_gb) {
                    //Background Pallete
                    if (address == 0xFF68) {
                        this.gameboy.ppu.writeRegister(address, value);
                    }
                    //Background Pallete
                    if (address == 0xFF69) {
                        this.gameboy.ppu.writeRegister(address, value);
                    }
                    //Sprite Pallete
                    if (address == 0xFF6A) {
                        this.gameboy.ppu.writeRegister(address, value);
                    }
                    //Sprite Pallete
                    if (address == 0xFF6B) {
                        this.gameboy.ppu.writeRegister(address, value);
                    }
                    //VRAM Bank
                    if (address == 0xFF4F) {
                        if (this.gameboy.ppu.hdma_in_progress)
                            return;
                        this.vram_bank = BitHelper.getBit(value, 0);
                    }
                    //VRAM DMA
                    if (address >= 0xFF51 && address <= 0xFF55) {
                        this.gameboy.ppu.writeRegister(address, value);
                    }
                    //Speed Mode
                    if (address == 0xFF4D) {
                        let color = 1;
                    }
                    //Infrared Port
                    if (address == 0xFF56) {
                        let color = 1;
                    }
                    //WRAM Bank
                    if (address == 0xFF70) {
                        this.wram_bank = value & 7;
                        if (this.wram_bank == 0)
                            this.wram_bank = 1;
                    }
                }

            }
            // High RAM (HRAM)
            else if (address >= 0xFF80 && address <= 0xFFFE) {

            }
            //Enable Interrupts
            else if (address == 0xFFFF) {
                this.gameboy.cpu.IE = value;
                return;
            }

            this.ram[real_address] = value;

        }

    }

}

class Instruction {
    id: number = 0;
    cyc: number = 0;  //number of cycles required to execute instruction
    reg1?: number;
    reg2?: number;
    reg16_1?: REGS16;
    reg16_2?: REGS16;
    immediate?: boolean = false;
    address?: number;
    bit?: number;
}

//16 bit combined register wrapper
class REGS16 {
    reg1: number;
    reg2: number;
}

//8 bit register indexers
const A = 0;
const B = 1;
const C = 2;
const D = 3;
const E = 4;
const F = 5;
const H = 6;
const L = 7;

const BC: REGS16 = {
    reg1: B,
    reg2: C
}

const DE: REGS16 = {
    reg1: D,
    reg2: E
}

const HL: REGS16 = {
    reg1: H,
    reg2: L
}

const AF: REGS16 = {
    reg1: A,
    reg2: F
}

const SP: REGS16 = {
    reg1: 1,
    reg2: 2
}

//Flag indexers
const FLAG_Z = 7;	// Zero
const FLAG_N = 6;	// Subtraction
const FLAG_H = 5;	// Half Carry
const FLAG_C = 4;	// Carry


// BITWISE OPERATORS CHEAT SHEET
// AND         &
// OR          |
// NOT         ~
// XOR         ^
// Left shift  <<
// Right shift >>


class CPU {


    gameboy: Gameboy;

    //Registers
    _regs: Buffer;

    //register wrappers
    get A(): number {
        return this._regs[0];
    }
    set A(value: number) {
        this._regs[0] = value & 0xff;
    }
    get B(): number {
        return this._regs[1];
    }
    set B(value: number) {
        this._regs[1] = value & 0xff;
    }
    get C(): number {
        return this._regs[2];
    }
    set C(value: number) {
        this._regs[2] = value & 0xff;
    }
    get D(): number {
        return this._regs[3];
    }
    set D(value: number) {
        this._regs[3] = value & 0xff;
    }
    get E(): number {
        return this._regs[4];
    }
    set E(value: number) {
        this._regs[4] = value & 0xff;
    }
    get F(): number {
        return this._regs[5];
    }
    set F(value: number) {
        this._regs[5] = value & 0xff;
    }
    get H(): number {
        return this._regs[6];
    }
    set H(value: number) {
        this._regs[6] = value & 0xff;
    }
    get L(): number {
        return this._regs[7];
    }
    set L(value: number) {
        this._regs[7] = value & 0xff;
    }


    SP: number = 0;   // Stack Pointer
    PC: number = 0x0;      // Program Counter (16 bit)
    IF: number = 0; //Interrupt Flag Register
    IE: number = 0; //Interrupt Enable Register

    //variables
    address: number = 0;    // address to get data based on addressing mode (for optimization reusable variable)
    halfcarry: number = 0; //used during half carry calculations (for optimization reusable variable)
    cycles: number = 0;  // number of cpu cycles left for the current operation
    hdma_cycles: number = 0;  // only for halting during HDMA Transfer
    all_instructions: any[] = [];
    cb_instructions: any[] = [];
    current_instruction: any;
    halt_mode: boolean = false; //if cpu is halted
    stop_mode: boolean = false; //if STOP command is received
    IME: boolean = false; //interrupt master enable
    next_op: string = '';
    next_addressmode: string = '';

    //color gameboy
    speedmode: number = 0;


    constructor(gameboy: Gameboy) {
        this.gameboy = gameboy;
        this._regs = Buffer.create(8);
        this.init_instructions();

    }

    //LOGGING
    loggingEnabled: boolean = false;
    fullLog: string = '';
    loggerCounter = 0;
    logger: string = '';
    logresultPrevious: string = '';
    startLogging = false;
    allCycles = 0;
    frameNumber = 0;

    clockTest() {
        this.clock();
    }

    clock(): number {

        //HDMA Cycles are only for gameboy color
        //TODO - put this somewhere else? 
        //regular gb doesn't need to check this
        if (this.hdma_cycles > 0) {
            this.hdma_cycles -= 4;
            this.processTimers(4);
            return 0;
        }
        //if CPU is halted then opcode execution
        //and system clock are suspended until
        //an interrupt occurs however the
        //PPU, Timers, and Interrupts continue to process
        else if (!this.halt_mode) {


            //Gameboy is actually 1 mhz not 4 mhz
            //so we subtract 4 cycles every clock
            //but we do things in 4's because most
            //internet opcode diagrams display things
            //in cycles of 4
            this.cycles = 4;


            //read in the opcode from the program counter
            let opcode = this.read(this.PC);

            //increment the program counter
            this.PC++;

            //fetch the instruction
            this.current_instruction = this.all_instructions[opcode];

            if (opcode != 0xCB) {

                //set number of cycles based on instruction
                this.cycles = this.current_instruction.cyc;

                switch (opcode) {
                    //ROW 0
                    case 0x00: this.NOP(this.current_instruction); break;
                    case 0x01: this.LoadReg16Immediate(this.current_instruction); break;
                    case 0x02: this.LoadMemFromReg8(this.current_instruction); break;
                    case 0x03: this.INC16(this.current_instruction); break;
                    case 0x04: this.INC8(this.current_instruction); break;
                    case 0x05: this.DEC8(this.current_instruction); break;
                    case 0x06: this.LoadReg8Immediate(this.current_instruction); break;
                    case 0x07: this.RLCA(this.current_instruction); break;
                    case 0x08: this.StackCopyToMem(this.current_instruction); break;
                    case 0x09: this.AddToHL(this.current_instruction); break;
                    case 0x0A: this.LoadReg8FromMem(this.current_instruction); break;
                    case 0x0B: this.DEC16(this.current_instruction); break;
                    case 0x0C: this.INC8(this.current_instruction); break;
                    case 0x0D: this.DEC8(this.current_instruction); break;
                    case 0x0E: this.LoadReg8Immediate(this.current_instruction); break;
                    case 0x0F: this.RRCA(this.current_instruction); break;

                    //ROW 1
                    case 0x10: this.STOP(this.current_instruction); break;
                    case 0x11: this.LoadReg16Immediate(this.current_instruction); break;
                    case 0x12: this.LoadMemFromReg8(this.current_instruction); break;
                    case 0x13: this.INC16(this.current_instruction); break;
                    case 0x14: this.INC8(this.current_instruction); break;
                    case 0x15: this.DEC8(this.current_instruction); break;
                    case 0x16: this.LoadReg8Immediate(this.current_instruction); break;
                    case 0x17: this.RLA(this.current_instruction); break;
                    case 0x18: this.JumpRelative(this.current_instruction); break;
                    case 0x19: this.AddToHL(this.current_instruction); break;
                    case 0x1A: this.LoadReg8FromMem(this.current_instruction); break;
                    case 0x1B: this.DEC16(this.current_instruction); break;
                    case 0x1C: this.INC8(this.current_instruction); break;
                    case 0x1D: this.DEC8(this.current_instruction); break;
                    case 0x1E: this.LoadReg8Immediate(this.current_instruction); break;
                    case 0x1F: this.RRA(this.current_instruction); break;

                    //ROW 2
                    case 0x20: this.JumpRelativeNZ(this.current_instruction); break;
                    case 0x21: this.LoadReg16Immediate(this.current_instruction); break;
                    case 0x22: this.LoadMemFromReg8Increment(this.current_instruction); break;
                    case 0x23: this.INC16(this.current_instruction); break;
                    case 0x24: this.INC8(this.current_instruction); break;
                    case 0x25: this.DEC8(this.current_instruction); break;
                    case 0x26: this.LoadReg8Immediate(this.current_instruction); break;
                    case 0x27: this.DAA(this.current_instruction); break;
                    case 0x28: this.JumpRelativeZ(this.current_instruction); break;
                    case 0x29: this.AddToHL(this.current_instruction); break;
                    case 0x2A: this.LoadReg8FromMemIncrement(this.current_instruction); break;
                    case 0x2B: this.DEC16(this.current_instruction); break;
                    case 0x2C: this.INC8(this.current_instruction); break;
                    case 0x2D: this.DEC8(this.current_instruction); break;
                    case 0x2E: this.LoadReg8Immediate(this.current_instruction); break;
                    case 0x2F: this.CPL(this.current_instruction); break;

                    //ROW 3
                    case 0x30: this.JumpRelativeNC(this.current_instruction); break;
                    case 0x31: this.StackLoadImmediate(this.current_instruction); break;
                    case 0x32: this.LoadMemFromReg8Decrement(this.current_instruction); break;
                    case 0x33: this.INC16(this.current_instruction); break;
                    case 0x34: this.INC16HL(this.current_instruction); break;
                    case 0x35: this.DEC16HL(this.current_instruction); break;
                    case 0x36: this.LoadMemImmediate(this.current_instruction); break;
                    case 0x37: this.SCF(this.current_instruction); break;
                    case 0x38: this.JumpRelativeC(this.current_instruction); break;
                    case 0x39: this.AddToHL(this.current_instruction); break;
                    case 0x3A: this.LoadReg8FromMemDecrement(this.current_instruction); break;
                    case 0x3B: this.DEC16(this.current_instruction); break;
                    case 0x3C: this.INC8(this.current_instruction); break;
                    case 0x3D: this.DEC8(this.current_instruction); break;
                    case 0x3E: this.LoadReg8Immediate(this.current_instruction); break;
                    case 0x3F: this.CCF(this.current_instruction); break;

                    //ROW 4
                    case 0x40: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x41: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x42: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x43: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x44: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x45: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x46: this.LoadReg8FromMem(this.current_instruction); break;
                    case 0x47: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x48: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x49: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x4A: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x4B: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x4C: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x4D: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x4E: this.LoadReg8FromMem(this.current_instruction); break;
                    case 0x4F: this.LoadReg8FromReg8(this.current_instruction); break;

                    //ROW 5
                    case 0x50: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x51: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x52: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x53: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x54: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x55: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x56: this.LoadReg8FromMem(this.current_instruction); break;
                    case 0x57: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x58: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x59: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x5A: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x5B: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x5C: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x5D: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x5E: this.LoadReg8FromMem(this.current_instruction); break;
                    case 0x5F: this.LoadReg8FromReg8(this.current_instruction); break;

                    //ROW 6
                    case 0x60: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x61: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x62: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x63: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x64: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x65: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x66: this.LoadReg8FromMem(this.current_instruction); break;
                    case 0x67: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x68: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x69: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x6A: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x6B: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x6C: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x6D: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x6E: this.LoadReg8FromMem(this.current_instruction); break;
                    case 0x6F: this.LoadReg8FromReg8(this.current_instruction); break;

                    //ROW 7
                    case 0x70: this.LoadMemFromReg8(this.current_instruction); break;
                    case 0x71: this.LoadMemFromReg8(this.current_instruction); break;
                    case 0x72: this.LoadMemFromReg8(this.current_instruction); break;
                    case 0x73: this.LoadMemFromReg8(this.current_instruction); break;
                    case 0x74: this.LoadMemFromReg8(this.current_instruction); break;
                    case 0x75: this.LoadMemFromReg8(this.current_instruction); break;
                    case 0x76: this.HALT(this.current_instruction); break;
                    case 0x77: this.LoadMemFromReg8(this.current_instruction); break;
                    case 0x78: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x79: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x7A: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x7B: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x7C: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x7D: this.LoadReg8FromReg8(this.current_instruction); break;
                    case 0x7E: this.LoadReg8FromMem(this.current_instruction); break;
                    case 0x7F: this.LoadReg8FromReg8(this.current_instruction); break;

                    //ROW 8
                    case 0x80: this.ADD(this.current_instruction); break;
                    case 0x81: this.ADD(this.current_instruction); break;
                    case 0x82: this.ADD(this.current_instruction); break;
                    case 0x83: this.ADD(this.current_instruction); break;
                    case 0x84: this.ADD(this.current_instruction); break;
                    case 0x85: this.ADD(this.current_instruction); break;
                    case 0x86: this.ADD(this.current_instruction); break;
                    case 0x87: this.ADD(this.current_instruction); break;
                    case 0x88: this.ADC(this.current_instruction); break;
                    case 0x89: this.ADC(this.current_instruction); break;
                    case 0x8A: this.ADC(this.current_instruction); break;
                    case 0x8B: this.ADC(this.current_instruction); break;
                    case 0x8C: this.ADC(this.current_instruction); break;
                    case 0x8D: this.ADC(this.current_instruction); break;
                    case 0x8E: this.ADC(this.current_instruction); break;
                    case 0x8F: this.ADC(this.current_instruction); break;

                    //ROW 9
                    case 0x90: this.SUB(this.current_instruction); break;
                    case 0x91: this.SUB(this.current_instruction); break;
                    case 0x92: this.SUB(this.current_instruction); break;
                    case 0x93: this.SUB(this.current_instruction); break;
                    case 0x94: this.SUB(this.current_instruction); break;
                    case 0x95: this.SUB(this.current_instruction); break;
                    case 0x96: this.SUB(this.current_instruction); break;
                    case 0x97: this.SUB(this.current_instruction); break;
                    case 0x98: this.SBC(this.current_instruction); break;
                    case 0x99: this.SBC(this.current_instruction); break;
                    case 0x9A: this.SBC(this.current_instruction); break;
                    case 0x9B: this.SBC(this.current_instruction); break;
                    case 0x9C: this.SBC(this.current_instruction); break;
                    case 0x9D: this.SBC(this.current_instruction); break;
                    case 0x9E: this.SBC(this.current_instruction); break;
                    case 0x9F: this.SBC(this.current_instruction); break;

                    //ROW A
                    case 0xA0: this.AND(this.current_instruction); break;
                    case 0xA1: this.AND(this.current_instruction); break;
                    case 0xA2: this.AND(this.current_instruction); break;
                    case 0xA3: this.AND(this.current_instruction); break;
                    case 0xA4: this.AND(this.current_instruction); break;
                    case 0xA5: this.AND(this.current_instruction); break;
                    case 0xA6: this.AND(this.current_instruction); break;
                    case 0xA7: this.AND(this.current_instruction); break;
                    case 0xA8: this.XOR(this.current_instruction); break;
                    case 0xA9: this.XOR(this.current_instruction); break;
                    case 0xAA: this.XOR(this.current_instruction); break;
                    case 0xAB: this.XOR(this.current_instruction); break;
                    case 0xAC: this.XOR(this.current_instruction); break;
                    case 0xAD: this.XOR(this.current_instruction); break;
                    case 0xAE: this.XOR(this.current_instruction); break;
                    case 0xAF: this.XOR(this.current_instruction); break;

                    //ROW B
                    case 0xB0: this.OR(this.current_instruction); break;
                    case 0xB1: this.OR(this.current_instruction); break;
                    case 0xB2: this.OR(this.current_instruction); break;
                    case 0xB3: this.OR(this.current_instruction); break;
                    case 0xB4: this.OR(this.current_instruction); break;
                    case 0xB5: this.OR(this.current_instruction); break;
                    case 0xB6: this.OR(this.current_instruction); break;
                    case 0xB7: this.OR(this.current_instruction); break;
                    case 0xB8: this.CP(this.current_instruction); break;
                    case 0xB9: this.CP(this.current_instruction); break;
                    case 0xBA: this.CP(this.current_instruction); break;
                    case 0xBB: this.CP(this.current_instruction); break;
                    case 0xBC: this.CP(this.current_instruction); break;
                    case 0xBD: this.CP(this.current_instruction); break;
                    case 0xBE: this.CP(this.current_instruction); break;
                    case 0xBF: this.CP(this.current_instruction); break;

                    //ROW C
                    case 0xC0: this.RET_NZ(this.current_instruction); break;
                    case 0xC1: this.POP(this.current_instruction); break;
                    case 0xC2: this.JumpNZ(this.current_instruction); break;
                    case 0xC3: this.JumpImmediate(this.current_instruction); break;
                    case 0xC4: this.CALL_NZ(this.current_instruction); break;
                    case 0xC5: this.PUSH(this.current_instruction); break;
                    case 0xC6: this.ADD(this.current_instruction); break;
                    case 0xC7: this.RST(this.current_instruction); break;
                    case 0xC8: this.RET_Z(this.current_instruction); break;
                    case 0xC9: this.RETURN(this.current_instruction); break;
                    case 0xCA: this.JumpZ(this.current_instruction); break;
                    case 0xCB: this.CB(this.current_instruction); break;
                    case 0xCC: this.CALL_Z(this.current_instruction); break;
                    case 0xCD: this.CALL(this.current_instruction); break;
                    case 0xCE: this.ADC(this.current_instruction); break;
                    case 0xCF: this.RST(this.current_instruction); break;

                    //ROW D
                    case 0xD0: this.RET_NC(this.current_instruction); break;
                    case 0xD1: this.POP(this.current_instruction); break;
                    case 0xD2: this.JumpNC(this.current_instruction); break;
                    case 0xD3: this.ILL(this.current_instruction); break;
                    case 0xD4: this.CALL_NC(this.current_instruction); break;
                    case 0xD5: this.PUSH(this.current_instruction); break;
                    case 0xD6: this.SUB(this.current_instruction); break;
                    case 0xD7: this.RST(this.current_instruction); break;
                    case 0xD8: this.RET_C(this.current_instruction); break;
                    case 0xD9: this.RETI(this.current_instruction); break;
                    case 0xDA: this.JumpC(this.current_instruction); break;
                    case 0xDB: this.ILL(this.current_instruction); break;
                    case 0xDC: this.CALL_C(this.current_instruction); break;
                    case 0xDD: this.ILL(this.current_instruction); break;
                    case 0xDE: this.SBC(this.current_instruction); break;
                    case 0xDF: this.RST(this.current_instruction); break;

                    //ROW E
                    case 0xE0: this.LDH(this.current_instruction); break;
                    case 0xE1: this.POP(this.current_instruction); break;
                    case 0xE2: this.LDC(this.current_instruction); break;
                    case 0xE3: this.ILL(this.current_instruction); break;
                    case 0xE4: this.ILL(this.current_instruction); break;
                    case 0xE5: this.PUSH(this.current_instruction); break;
                    case 0xE6: this.AND(this.current_instruction); break;
                    case 0xE7: this.RST(this.current_instruction); break;
                    case 0xE8: this.ADD_SP(this.current_instruction); break;
                    case 0xE9: this.JumpHL(this.current_instruction); break;
                    case 0xEA: this.LoadMemImmediateFromReg8(this.current_instruction); break;
                    case 0xEB: this.ILL(this.current_instruction); break;
                    case 0xEC: this.ILL(this.current_instruction); break;
                    case 0xED: this.ILL(this.current_instruction); break;
                    case 0xEE: this.XOR(this.current_instruction); break;
                    case 0xEF: this.RST(this.current_instruction); break;

                    //ROW F
                    case 0xF0: this.LDH(this.current_instruction); break;
                    case 0xF1: this.POP(this.current_instruction); break;
                    case 0xF2: this.LDC(this.current_instruction); break;
                    case 0xF3: this.DI(this.current_instruction); break;
                    case 0xF4: this.ILL(this.current_instruction); break;
                    case 0xF5: this.PUSH(this.current_instruction); break;
                    case 0xF6: this.OR(this.current_instruction); break;
                    case 0xF7: this.RST(this.current_instruction); break;
                    case 0xF8: this.LD_HL_SPADD(this.current_instruction); break;
                    case 0xF9: this.LD_SP_HL(this.current_instruction); break;
                    case 0xFA: this.LoadReg8FromMemImmediate(this.current_instruction); break;
                    case 0xFB: this.EI(this.current_instruction); break;
                    case 0xFC: this.ILL(this.current_instruction); break;
                    case 0xFD: this.ILL(this.current_instruction); break;
                    case 0xFE: this.CP(this.current_instruction); break;
                    case 0xFF: this.RST(this.current_instruction); break;
                }
            }
            else {
                opcode = this.read(this.PC);
                this.PC++;
                this.current_instruction = this.cb_instructions[opcode];

                //set number of cycles based on instruction
                this.cycles = this.current_instruction.cyc;

                switch (opcode) {

                    //ROW 0
                    case 0x00: this.RLC(this.current_instruction); break;
                    case 0x01: this.RLC(this.current_instruction); break;
                    case 0x02: this.RLC(this.current_instruction); break;
                    case 0x03: this.RLC(this.current_instruction); break;
                    case 0x04: this.RLC(this.current_instruction); break;
                    case 0x05: this.RLC(this.current_instruction); break;
                    case 0x06: this.RLC(this.current_instruction); break;
                    case 0x07: this.RLC(this.current_instruction); break;
                    case 0x08: this.RRC(this.current_instruction); break;
                    case 0x09: this.RRC(this.current_instruction); break;
                    case 0x0A: this.RRC(this.current_instruction); break;
                    case 0x0B: this.RRC(this.current_instruction); break;
                    case 0x0C: this.RRC(this.current_instruction); break;
                    case 0x0D: this.RRC(this.current_instruction); break;
                    case 0x0E: this.RRC(this.current_instruction); break;
                    case 0x0F: this.RRC(this.current_instruction); break;

                    //ROW 1
                    case 0x10: this.RL(this.current_instruction); break;
                    case 0x11: this.RL(this.current_instruction); break;
                    case 0x12: this.RL(this.current_instruction); break;
                    case 0x13: this.RL(this.current_instruction); break;
                    case 0x14: this.RL(this.current_instruction); break;
                    case 0x15: this.RL(this.current_instruction); break;
                    case 0x16: this.RL(this.current_instruction); break;
                    case 0x17: this.RL(this.current_instruction); break;
                    case 0x18: this.RR(this.current_instruction); break;
                    case 0x19: this.RR(this.current_instruction); break;
                    case 0x1A: this.RR(this.current_instruction); break;
                    case 0x1B: this.RR(this.current_instruction); break;
                    case 0x1C: this.RR(this.current_instruction); break;
                    case 0x1D: this.RR(this.current_instruction); break;
                    case 0x1E: this.RR(this.current_instruction); break;
                    case 0x1F: this.RR(this.current_instruction); break;

                    //ROW 2
                    case 0x20: this.SLA(this.current_instruction); break;
                    case 0x21: this.SLA(this.current_instruction); break;
                    case 0x22: this.SLA(this.current_instruction); break;
                    case 0x23: this.SLA(this.current_instruction); break;
                    case 0x24: this.SLA(this.current_instruction); break;
                    case 0x25: this.SLA(this.current_instruction); break;
                    case 0x26: this.SLA(this.current_instruction); break;
                    case 0x27: this.SLA(this.current_instruction); break;
                    case 0x28: this.SRA(this.current_instruction); break;
                    case 0x29: this.SRA(this.current_instruction); break;
                    case 0x2A: this.SRA(this.current_instruction); break;
                    case 0x2B: this.SRA(this.current_instruction); break;
                    case 0x2C: this.SRA(this.current_instruction); break;
                    case 0x2D: this.SRA(this.current_instruction); break;
                    case 0x2E: this.SRA(this.current_instruction); break;
                    case 0x2F: this.SRA(this.current_instruction); break;

                    //ROW 3
                    case 0x30: this.SWAP(this.current_instruction); break;
                    case 0x31: this.SWAP(this.current_instruction); break;
                    case 0x32: this.SWAP(this.current_instruction); break;
                    case 0x33: this.SWAP(this.current_instruction); break;
                    case 0x34: this.SWAP(this.current_instruction); break;
                    case 0x35: this.SWAP(this.current_instruction); break;
                    case 0x36: this.SWAP(this.current_instruction); break;
                    case 0x37: this.SWAP(this.current_instruction); break;
                    case 0x38: this.SRL(this.current_instruction); break;
                    case 0x39: this.SRL(this.current_instruction); break;
                    case 0x3A: this.SRL(this.current_instruction); break;
                    case 0x3B: this.SRL(this.current_instruction); break;
                    case 0x3C: this.SRL(this.current_instruction); break;
                    case 0x3D: this.SRL(this.current_instruction); break;
                    case 0x3E: this.SRL(this.current_instruction); break;
                    case 0x3F: this.SRL(this.current_instruction); break;

                    //ROW 4
                    case 0x40: this.BIT(this.current_instruction); break;
                    case 0x41: this.BIT(this.current_instruction); break;
                    case 0x42: this.BIT(this.current_instruction); break;
                    case 0x43: this.BIT(this.current_instruction); break;
                    case 0x44: this.BIT(this.current_instruction); break;
                    case 0x45: this.BIT(this.current_instruction); break;
                    case 0x46: this.BIT(this.current_instruction); break;
                    case 0x47: this.BIT(this.current_instruction); break;
                    case 0x48: this.BIT(this.current_instruction); break;
                    case 0x49: this.BIT(this.current_instruction); break;
                    case 0x4A: this.BIT(this.current_instruction); break;
                    case 0x4B: this.BIT(this.current_instruction); break;
                    case 0x4C: this.BIT(this.current_instruction); break;
                    case 0x4D: this.BIT(this.current_instruction); break;
                    case 0x4E: this.BIT(this.current_instruction); break;
                    case 0x4F: this.BIT(this.current_instruction); break;

                    //ROW 5
                    case 0x50: this.BIT(this.current_instruction); break;
                    case 0x51: this.BIT(this.current_instruction); break;
                    case 0x52: this.BIT(this.current_instruction); break;
                    case 0x53: this.BIT(this.current_instruction); break;
                    case 0x54: this.BIT(this.current_instruction); break;
                    case 0x55: this.BIT(this.current_instruction); break;
                    case 0x56: this.BIT(this.current_instruction); break;
                    case 0x57: this.BIT(this.current_instruction); break;
                    case 0x58: this.BIT(this.current_instruction); break;
                    case 0x59: this.BIT(this.current_instruction); break;
                    case 0x5A: this.BIT(this.current_instruction); break;
                    case 0x5B: this.BIT(this.current_instruction); break;
                    case 0x5C: this.BIT(this.current_instruction); break;
                    case 0x5D: this.BIT(this.current_instruction); break;
                    case 0x5E: this.BIT(this.current_instruction); break;
                    case 0x5F: this.BIT(this.current_instruction); break;

                    //ROW 6
                    case 0x60: this.BIT(this.current_instruction); break;
                    case 0x61: this.BIT(this.current_instruction); break;
                    case 0x62: this.BIT(this.current_instruction); break;
                    case 0x63: this.BIT(this.current_instruction); break;
                    case 0x64: this.BIT(this.current_instruction); break;
                    case 0x65: this.BIT(this.current_instruction); break;
                    case 0x66: this.BIT(this.current_instruction); break;
                    case 0x67: this.BIT(this.current_instruction); break;
                    case 0x68: this.BIT(this.current_instruction); break;
                    case 0x69: this.BIT(this.current_instruction); break;
                    case 0x6A: this.BIT(this.current_instruction); break;
                    case 0x6B: this.BIT(this.current_instruction); break;
                    case 0x6C: this.BIT(this.current_instruction); break;
                    case 0x6D: this.BIT(this.current_instruction); break;
                    case 0x6E: this.BIT(this.current_instruction); break;
                    case 0x6F: this.BIT(this.current_instruction); break;

                    //ROW 7
                    case 0x70: this.BIT(this.current_instruction); break;
                    case 0x71: this.BIT(this.current_instruction); break;
                    case 0x72: this.BIT(this.current_instruction); break;
                    case 0x73: this.BIT(this.current_instruction); break;
                    case 0x74: this.BIT(this.current_instruction); break;
                    case 0x75: this.BIT(this.current_instruction); break;
                    case 0x76: this.BIT(this.current_instruction); break;
                    case 0x77: this.BIT(this.current_instruction); break;
                    case 0x78: this.BIT(this.current_instruction); break;
                    case 0x79: this.BIT(this.current_instruction); break;
                    case 0x7A: this.BIT(this.current_instruction); break;
                    case 0x7B: this.BIT(this.current_instruction); break;
                    case 0x7C: this.BIT(this.current_instruction); break;
                    case 0x7D: this.BIT(this.current_instruction); break;
                    case 0x7E: this.BIT(this.current_instruction); break;
                    case 0x7F: this.BIT(this.current_instruction); break;

                    //ROW 8
                    case 0x80: this.RES(this.current_instruction); break;
                    case 0x81: this.RES(this.current_instruction); break;
                    case 0x82: this.RES(this.current_instruction); break;
                    case 0x83: this.RES(this.current_instruction); break;
                    case 0x84: this.RES(this.current_instruction); break;
                    case 0x85: this.RES(this.current_instruction); break;
                    case 0x86: this.RES(this.current_instruction); break;
                    case 0x87: this.RES(this.current_instruction); break;
                    case 0x88: this.RES(this.current_instruction); break;
                    case 0x89: this.RES(this.current_instruction); break;
                    case 0x8A: this.RES(this.current_instruction); break;
                    case 0x8B: this.RES(this.current_instruction); break;
                    case 0x8C: this.RES(this.current_instruction); break;
                    case 0x8D: this.RES(this.current_instruction); break;
                    case 0x8E: this.RES(this.current_instruction); break;
                    case 0x8F: this.RES(this.current_instruction); break;

                    //ROW 9
                    case 0x90: this.RES(this.current_instruction); break;
                    case 0x91: this.RES(this.current_instruction); break;
                    case 0x92: this.RES(this.current_instruction); break;
                    case 0x93: this.RES(this.current_instruction); break;
                    case 0x94: this.RES(this.current_instruction); break;
                    case 0x95: this.RES(this.current_instruction); break;
                    case 0x96: this.RES(this.current_instruction); break;
                    case 0x97: this.RES(this.current_instruction); break;
                    case 0x98: this.RES(this.current_instruction); break;
                    case 0x99: this.RES(this.current_instruction); break;
                    case 0x9A: this.RES(this.current_instruction); break;
                    case 0x9B: this.RES(this.current_instruction); break;
                    case 0x9C: this.RES(this.current_instruction); break;
                    case 0x9D: this.RES(this.current_instruction); break;
                    case 0x9E: this.RES(this.current_instruction); break;
                    case 0x9F: this.RES(this.current_instruction); break;

                    //ROW A
                    case 0xA0: this.RES(this.current_instruction); break;
                    case 0xA1: this.RES(this.current_instruction); break;
                    case 0xA2: this.RES(this.current_instruction); break;
                    case 0xA3: this.RES(this.current_instruction); break;
                    case 0xA4: this.RES(this.current_instruction); break;
                    case 0xA5: this.RES(this.current_instruction); break;
                    case 0xA6: this.RES(this.current_instruction); break;
                    case 0xA7: this.RES(this.current_instruction); break;
                    case 0xA8: this.RES(this.current_instruction); break;
                    case 0xA9: this.RES(this.current_instruction); break;
                    case 0xAA: this.RES(this.current_instruction); break;
                    case 0xAB: this.RES(this.current_instruction); break;
                    case 0xAC: this.RES(this.current_instruction); break;
                    case 0xAD: this.RES(this.current_instruction); break;
                    case 0xAE: this.RES(this.current_instruction); break;
                    case 0xAF: this.RES(this.current_instruction); break;

                    //ROW B
                    case 0xB0: this.RES(this.current_instruction); break;
                    case 0xB1: this.RES(this.current_instruction); break;
                    case 0xB2: this.RES(this.current_instruction); break;
                    case 0xB3: this.RES(this.current_instruction); break;
                    case 0xB4: this.RES(this.current_instruction); break;
                    case 0xB5: this.RES(this.current_instruction); break;
                    case 0xB6: this.RES(this.current_instruction); break;
                    case 0xB7: this.RES(this.current_instruction); break;
                    case 0xB8: this.RES(this.current_instruction); break;
                    case 0xB9: this.RES(this.current_instruction); break;
                    case 0xBA: this.RES(this.current_instruction); break;
                    case 0xBB: this.RES(this.current_instruction); break;
                    case 0xBC: this.RES(this.current_instruction); break;
                    case 0xBD: this.RES(this.current_instruction); break;
                    case 0xBE: this.RES(this.current_instruction); break;
                    case 0xBF: this.RES(this.current_instruction); break;

                    //ROW C
                    case 0xC0: this.SET(this.current_instruction); break;
                    case 0xC1: this.SET(this.current_instruction); break;
                    case 0xC2: this.SET(this.current_instruction); break;
                    case 0xC3: this.SET(this.current_instruction); break;
                    case 0xC4: this.SET(this.current_instruction); break;
                    case 0xC5: this.SET(this.current_instruction); break;
                    case 0xC6: this.SET(this.current_instruction); break;
                    case 0xC7: this.SET(this.current_instruction); break;
                    case 0xC8: this.SET(this.current_instruction); break;
                    case 0xC9: this.SET(this.current_instruction); break;
                    case 0xCA: this.SET(this.current_instruction); break;
                    case 0xCB: this.SET(this.current_instruction); break;
                    case 0xCC: this.SET(this.current_instruction); break;
                    case 0xCD: this.SET(this.current_instruction); break;
                    case 0xCE: this.SET(this.current_instruction); break;
                    case 0xCF: this.SET(this.current_instruction); break;

                    //ROW D
                    case 0xD0: this.SET(this.current_instruction); break;
                    case 0xD1: this.SET(this.current_instruction); break;
                    case 0xD2: this.SET(this.current_instruction); break;
                    case 0xD3: this.SET(this.current_instruction); break;
                    case 0xD4: this.SET(this.current_instruction); break;
                    case 0xD5: this.SET(this.current_instruction); break;
                    case 0xD6: this.SET(this.current_instruction); break;
                    case 0xD7: this.SET(this.current_instruction); break;
                    case 0xD8: this.SET(this.current_instruction); break;
                    case 0xD9: this.SET(this.current_instruction); break;
                    case 0xDA: this.SET(this.current_instruction); break;
                    case 0xDB: this.SET(this.current_instruction); break;
                    case 0xDC: this.SET(this.current_instruction); break;
                    case 0xDD: this.SET(this.current_instruction); break;
                    case 0xDE: this.SET(this.current_instruction); break;
                    case 0xDF: this.SET(this.current_instruction); break;

                    //ROW E
                    case 0xE0: this.SET(this.current_instruction); break;
                    case 0xE1: this.SET(this.current_instruction); break;
                    case 0xE2: this.SET(this.current_instruction); break;
                    case 0xE3: this.SET(this.current_instruction); break;
                    case 0xE4: this.SET(this.current_instruction); break;
                    case 0xE5: this.SET(this.current_instruction); break;
                    case 0xE6: this.SET(this.current_instruction); break;
                    case 0xE7: this.SET(this.current_instruction); break;
                    case 0xE8: this.SET(this.current_instruction); break;
                    case 0xE9: this.SET(this.current_instruction); break;
                    case 0xEA: this.SET(this.current_instruction); break;
                    case 0xEB: this.SET(this.current_instruction); break;
                    case 0xEC: this.SET(this.current_instruction); break;
                    case 0xED: this.SET(this.current_instruction); break;
                    case 0xEE: this.SET(this.current_instruction); break;
                    case 0xEF: this.SET(this.current_instruction); break;

                    //ROW F
                    case 0xF0: this.SET(this.current_instruction); break;
                    case 0xF1: this.SET(this.current_instruction); break;
                    case 0xF2: this.SET(this.current_instruction); break;
                    case 0xF3: this.SET(this.current_instruction); break;
                    case 0xF4: this.SET(this.current_instruction); break;
                    case 0xF5: this.SET(this.current_instruction); break;
                    case 0xF6: this.SET(this.current_instruction); break;
                    case 0xF7: this.SET(this.current_instruction); break;
                    case 0xF8: this.SET(this.current_instruction); break;
                    case 0xF9: this.SET(this.current_instruction); break;
                    case 0xFA: this.SET(this.current_instruction); break;
                    case 0xFB: this.SET(this.current_instruction); break;
                    case 0xFC: this.SET(this.current_instruction); break;
                    case 0xFD: this.SET(this.current_instruction); break;
                    case 0xFE: this.SET(this.current_instruction); break;
                    case 0xFF: this.SET(this.current_instruction); break;
                }
            }


            //decrement the cpu cycles counter;
            this.processTimers(this.cycles);

            this.cycles -= 4;

        }
        else {
            this.processTimers(4);
        }

        this.processInterrupts();

        return this.cycles;

        //do I need this? may fix bugs down the road
        //make sure stack pointer doesn't overflow
        // this.SP &= 0xFFFF;
    }

    /* TIMERS */

    //  TIMER_DIV
    //This register is incremented 16384 times/sec
    //writing any value sets it to $00.
    //-----------------
    //  TIMER_TIMA
    //This timer is incremented by a clock frequency 
    //specified by the TAC register and it generates
    //an interrupt when it overflows
    //-----------------
    //  TIMER_TMA
    //Timer Modulo - When the TIMA overflows this data
    //will be loaded 
    //-----------------
    //  TIMER_TAC
    //Timer Control - Bit 2 - Timer Stop
    //0 - Stop Timer
    //1 - Start Timer
    //Bits 1 and 0 Input Clock Select
    //00: 4.096 KHz
    //01: 262.144 Khz
    //10: 65.536 KHz
    //11: 16.384 KHz

    TIMER_DIV: number = 0;
    TIMER_TIMA: number = 0;
    TIMER_TMA: number = 0;
    TIMER_TAC: number = 0;

    //Timer Support Variables
    dividerCounter = 0;
    main_clock_counter = 0;
    timerSpeed = 1;
    timerEnabled = false;

    processTimers(cycles: number) {

        //Divider
        this.dividerCounter += cycles;
        if (this.dividerCounter > 255) {
            this.dividerCounter -= 256
            this.TIMER_DIV++;
            if (this.TIMER_DIV > 255)
                this.TIMER_DIV = 0;
        }

        //Timer
        if (this.timerEnabled) {
            this.main_clock_counter -= cycles;

            //allow it to catch up to cpu
            //so make it a while loop
            while (this.main_clock_counter < 0) {
                this.main_clock_counter += this.timerSpeed;
                this.TIMER_TIMA++;

                if (this.TIMER_TIMA > 255) {
                    this.TIMER_TIMA = this.TIMER_TMA;
                    this.halt_mode = false;
                    this.request_interrupt_timer();
                }
            }
        }

    }

    request_interrupt_vblank() {
        this.IF = this.setBit(this.IF, 0, 1);
    }
    request_interrupt_lcd() {
        this.IF = this.setBit(this.IF, 1, 1);
    }
    request_interrupt_timer() {
        this.IF = this.setBit(this.IF, 2, 1);
    }
    request_interrupt_serial() {
        this.IF = this.setBit(this.IF, 3, 1);
    }
    request_interrupt_joypad() {
        this.IF = this.setBit(this.IF, 4, 1);
    }


    /* Interrupts */

    // Interrupts List
    // BIT 0 - VBlank (0x40)
    // BIT 1 - LCD stat (0x48)
    // BIT 2 - Timer (0x50)
    // BIT 3 - Serial (0x58)
    // BIT 4 - Joypad(0x60)
    // -------------------
    // IE Flag - Enables Specific Interrupt (0xFFFF)
    // IF Flag - Gets Reset When Specific Interrupt Occurred (0xFF0F)

    processInterrupts() {

        // Interrupt is triggered if following 3 conditions are met
        // 1) Master IME Register is Enabled
        // 2) Corresponding IE Flag is Enabled
        // 3) Corresponding IF Flag is Enabled

        let intr_vblank = this.getBit(this.IE, 0) & this.getBit(this.IF, 0);
        let intr_lcd = this.getBit(this.IE, 1) & this.getBit(this.IF, 1);
        let intr_timer = this.getBit(this.IE, 2) & this.getBit(this.IF, 2);
        let intr_serial = this.getBit(this.IE, 3) & this.getBit(this.IF, 3);
        let intr_joypad = this.getBit(this.IE, 4) & this.getBit(this.IF, 4);

        //if any of these interrupts are requested we 
        //unhalt the cpu even if the interrupt itself
        //doesn't run because IME might be turned off
        if (intr_vblank || intr_lcd || intr_timer || intr_serial || intr_joypad) {
            this.halt_mode = false;
        }

        if (this.IME) {
            //can only trigger 1 interrupt at a time 
            //based on the priority list above
            if (intr_vblank) {
                this.IF = this.setBit(this.IF, 0, 0);
                this.initiateInterrupt(0x40);
            }
            else if (intr_lcd) {
                this.IF = this.setBit(this.IF, 1, 0);
                this.initiateInterrupt(0x48);
            }
            else if (intr_timer) {
                this.IF = this.setBit(this.IF, 2, 0);
                this.initiateInterrupt(0x50);
            }
            else if (intr_serial) {
                this.IF = this.setBit(this.IF, 3, 0);
                this.initiateInterrupt(0x58);
            }
            else if (intr_joypad) {
                this.IF = this.setBit(this.IF, 4, 0);
                this.initiateInterrupt(0x60);
            }

        }

    }

    //clear the IME Flag so that other interrupts don't happen
    //push the Program Counter to the Stack
    //then jump to the specified interrupt address
    initiateInterrupt(address: number) {

        //this wasn't in any of the documentation but
        //it seems the consensus is interrupts take
        //up to 20 cycles to complete
        //http://forums.nesdev.com/viewtopic.php?t=7152
        this.cycles += 20;
        this.IME = false;

        //push PC to Stack
        this.SP -= 2;
        let returnProgramCounter = this.PC;
        this.write(this.SP, returnProgramCounter & 0xFF); //first low byte
        this.write(this.SP + 1, returnProgramCounter >> 8); //then high byte
        this.PC = address;

    }


    //OPCODE MATRIX
    init_instructions() {
        this.all_instructions = [

            //ROW 0
            { id: 0x00, cyc: 4 },
            { id: 0x01, cyc: 12, reg16_1: BC },
            { id: 0x02, cyc: 8, reg16_1: BC, reg1: A },
            { id: 0x03, cyc: 8, reg16_1: BC },
            { id: 0x04, cyc: 4, reg1: B },
            { id: 0x05, cyc: 4, reg1: B },
            { id: 0x06, cyc: 8, reg1: B },
            { id: 0x07, cyc: 4, reg1: A },
            { id: 0x08, cyc: 20 },
            { id: 0x09, cyc: 8, reg16_1: BC },
            { id: 0x0A, cyc: 8, reg1: A, reg16_1: BC },
            { id: 0x0B, cyc: 8, reg16_1: BC },
            { id: 0x0C, cyc: 4, reg1: C },
            { id: 0x0D, cyc: 4, reg1: C },
            { id: 0x0E, cyc: 8, reg1: C },
            { id: 0x0F, cyc: 4, reg1: A },

            //ROW 1
            { id: 0x10, cyc: 4 },
            { id: 0x11, cyc: 12, reg16_1: DE },
            { id: 0x12, cyc: 8, reg16_1: DE, reg1: A },
            { id: 0x13, cyc: 8, reg16_1: DE },
            { id: 0x14, cyc: 4, reg1: D },
            { id: 0x15, cyc: 4, reg1: D },
            { id: 0x16, cyc: 8, reg1: D },
            { id: 0x17, cyc: 4, reg1: A },
            { id: 0x18, cyc: 12 },
            { id: 0x19, cyc: 8, reg16_1: DE },
            { id: 0x1A, cyc: 8, reg1: A, reg16_1: DE },
            { id: 0x1B, cyc: 8, reg16_1: DE },
            { id: 0x1C, cyc: 4, reg1: E },
            { id: 0x1D, cyc: 4, reg1: E },
            { id: 0x1E, cyc: 8, reg1: E },
            { id: 0x1F, cyc: 4, reg1: A },

            //ROW 2
            { id: 0x20, cyc: 8 },
            { id: 0x21, cyc: 12, reg16_1: HL },
            { id: 0x22, cyc: 8, reg16_1: HL, reg1: A },
            { id: 0x23, cyc: 8, reg16_1: HL },
            { id: 0x24, cyc: 4, reg1: H },
            { id: 0x25, cyc: 4, reg1: H },
            { id: 0x26, cyc: 8, reg1: H },
            { id: 0x27, cyc: 4 },
            { id: 0x28, cyc: 8 },
            { id: 0x29, cyc: 8, reg16_1: HL },
            { id: 0x2A, cyc: 8, reg1: A, reg16_1: HL },
            { id: 0x2B, cyc: 8, reg16_1: HL },
            { id: 0x2C, cyc: 4, reg1: L },
            { id: 0x2D, cyc: 4, reg1: L },
            { id: 0x2E, cyc: 8, reg1: L },
            { id: 0x2F, cyc: 4 },

            //ROW 3
            { id: 0x30, cyc: 8 },
            { id: 0x31, cyc: 12 },
            { id: 0x32, cyc: 8, reg16_1: HL, reg1: A },
            { id: 0x33, cyc: 8, reg16_1: SP },
            { id: 0x34, cyc: 12 },
            { id: 0x35, cyc: 12 },
            { id: 0x36, cyc: 12, reg16_1: HL },
            { id: 0x37, cyc: 4 },
            { id: 0x38, cyc: 8 },
            { id: 0x39, cyc: 8, reg16_1: SP },
            { id: 0x3A, cyc: 8, reg1: A, reg16_1: HL },
            { id: 0x3B, cyc: 8, reg16_1: SP },
            { id: 0x3C, cyc: 4, reg1: A },
            { id: 0x3D, cyc: 4, reg1: A },
            { id: 0x3E, cyc: 8, reg1: A },
            { id: 0x3F, cyc: 4 },

            //ROW 4
            { id: 0x40, cyc: 4, reg1: B, reg2: B },
            { id: 0x41, cyc: 4, reg1: B, reg2: C },
            { id: 0x42, cyc: 4, reg1: B, reg2: D },
            { id: 0x43, cyc: 4, reg1: B, reg2: E },
            { id: 0x44, cyc: 4, reg1: B, reg2: H },
            { id: 0x45, cyc: 4, reg1: B, reg2: L },
            { id: 0x46, cyc: 8, reg1: B, reg16_1: HL },
            { id: 0x47, cyc: 4, reg1: B, reg2: A },
            { id: 0x48, cyc: 4, reg1: C, reg2: B },
            { id: 0x49, cyc: 4, reg1: C, reg2: C },
            { id: 0x4A, cyc: 4, reg1: C, reg2: D },
            { id: 0x4B, cyc: 4, reg1: C, reg2: E },
            { id: 0x4C, cyc: 4, reg1: C, reg2: H },
            { id: 0x4D, cyc: 4, reg1: C, reg2: L },
            { id: 0x4E, cyc: 8, reg1: C, reg16_1: HL },
            { id: 0x4F, cyc: 4, reg1: C, reg2: A },

            //ROW 5
            { id: 0x50, cyc: 4, reg1: D, reg2: B },
            { id: 0x51, cyc: 4, reg1: D, reg2: C },
            { id: 0x52, cyc: 4, reg1: D, reg2: D },
            { id: 0x53, cyc: 4, reg1: D, reg2: E },
            { id: 0x54, cyc: 4, reg1: D, reg2: H },
            { id: 0x55, cyc: 4, reg1: D, reg2: L },
            { id: 0x56, cyc: 8, reg1: D, reg16_1: HL },
            { id: 0x57, cyc: 4, reg1: D, reg2: A },
            { id: 0x58, cyc: 4, reg1: E, reg2: B },
            { id: 0x59, cyc: 4, reg1: E, reg2: C },
            { id: 0x5A, cyc: 4, reg1: E, reg2: D },
            { id: 0x5B, cyc: 4, reg1: E, reg2: E },
            { id: 0x5C, cyc: 4, reg1: E, reg2: H },
            { id: 0x5D, cyc: 4, reg1: E, reg2: L },
            { id: 0x5E, cyc: 8, reg1: E, reg16_1: HL },
            { id: 0x5F, cyc: 4, reg1: E, reg2: A },

            //ROW 6
            { id: 0x60, cyc: 4, reg1: H, reg2: B },
            { id: 0x61, cyc: 4, reg1: H, reg2: C },
            { id: 0x62, cyc: 4, reg1: H, reg2: D },
            { id: 0x63, cyc: 4, reg1: H, reg2: E },
            { id: 0x64, cyc: 4, reg1: H, reg2: H },
            { id: 0x65, cyc: 4, reg1: H, reg2: L },
            { id: 0x66, cyc: 8, reg1: H, reg16_1: HL },
            { id: 0x67, cyc: 4, reg1: H, reg2: A },
            { id: 0x68, cyc: 4, reg1: L, reg2: B },
            { id: 0x69, cyc: 4, reg1: L, reg2: C },
            { id: 0x6A, cyc: 4, reg1: L, reg2: D },
            { id: 0x6B, cyc: 4, reg1: L, reg2: E },
            { id: 0x6C, cyc: 4, reg1: L, reg2: H },
            { id: 0x6D, cyc: 4, reg1: L, reg2: L },
            { id: 0x6E, cyc: 8, reg1: L, reg16_1: HL },
            { id: 0x6F, cyc: 4, reg1: L, reg2: A },

            //ROW 7
            { id: 0x70, cyc: 8, reg16_1: HL, reg1: B },
            { id: 0x71, cyc: 8, reg16_1: HL, reg1: C },
            { id: 0x72, cyc: 8, reg16_1: HL, reg1: D },
            { id: 0x73, cyc: 8, reg16_1: HL, reg1: E },
            { id: 0x74, cyc: 8, reg16_1: HL, reg1: H },
            { id: 0x75, cyc: 8, reg16_1: HL, reg1: L },
            { id: 0x76, cyc: 4 },
            { id: 0x77, cyc: 8, reg16_1: HL, reg1: A },
            { id: 0x78, cyc: 4, reg1: A, reg2: B },
            { id: 0x79, cyc: 4, reg1: A, reg2: C },
            { id: 0x7A, cyc: 4, reg1: A, reg2: D },
            { id: 0x7B, cyc: 4, reg1: A, reg2: E },
            { id: 0x7C, cyc: 4, reg1: A, reg2: H },
            { id: 0x7D, cyc: 4, reg1: A, reg2: L },
            { id: 0x7E, cyc: 8, reg1: A, reg16_1: HL },
            { id: 0x7F, cyc: 4, reg1: A, reg2: A },

            //ROW 8
            { id: 0x80, cyc: 4, reg1: B },
            { id: 0x81, cyc: 4, reg1: C },
            { id: 0x82, cyc: 4, reg1: D },
            { id: 0x83, cyc: 4, reg1: E },
            { id: 0x84, cyc: 4, reg1: H },
            { id: 0x85, cyc: 4, reg1: L },
            { id: 0x86, cyc: 8, reg16_1: HL },
            { id: 0x87, cyc: 4, reg1: A },
            { id: 0x88, cyc: 4, reg1: B },
            { id: 0x89, cyc: 4, reg1: C },
            { id: 0x8A, cyc: 4, reg1: D },
            { id: 0x8B, cyc: 4, reg1: E },
            { id: 0x8C, cyc: 4, reg1: H },
            { id: 0x8D, cyc: 4, reg1: L },
            { id: 0x8E, cyc: 8, reg16_1: HL },
            { id: 0x8F, cyc: 4, reg1: A },

            //ROW 9
            { id: 0x90, cyc: 4, reg1: B },
            { id: 0x91, cyc: 4, reg1: C },
            { id: 0x92, cyc: 4, reg1: D },
            { id: 0x93, cyc: 4, reg1: E },
            { id: 0x94, cyc: 4, reg1: H },
            { id: 0x95, cyc: 4, reg1: L },
            { id: 0x96, cyc: 8, reg16_1: HL },
            { id: 0x97, cyc: 4, reg1: A },
            { id: 0x98, cyc: 4, reg1: B },
            { id: 0x99, cyc: 4, reg1: C },
            { id: 0x9A, cyc: 4, reg1: D },
            { id: 0x9B, cyc: 4, reg1: E },
            { id: 0x9C, cyc: 4, reg1: H },
            { id: 0x9D, cyc: 4, reg1: L },
            { id: 0x9E, cyc: 8, reg16_1: HL },
            { id: 0x9F, cyc: 4, reg1: A },

            //ROW A
            { id: 0xA0, cyc: 4, reg1: B },
            { id: 0xA1, cyc: 4, reg1: C },
            { id: 0xA2, cyc: 4, reg1: D },
            { id: 0xA3, cyc: 4, reg1: E },
            { id: 0xA4, cyc: 4, reg1: H },
            { id: 0xA5, cyc: 4, reg1: L },
            { id: 0xA6, cyc: 8, reg16_1: HL },
            { id: 0xA7, cyc: 4, reg1: A },
            { id: 0xA8, cyc: 4, reg1: B },
            { id: 0xA9, cyc: 4, reg1: C },
            { id: 0xAA, cyc: 4, reg1: D },
            { id: 0xAB, cyc: 4, reg1: E },
            { id: 0xAC, cyc: 4, reg1: H },
            { id: 0xAD, cyc: 4, reg1: L },
            { id: 0xAE, cyc: 8, reg16_1: HL },
            { id: 0xAF, cyc: 4, reg1: A },

            //ROW B
            { id: 0xB0, cyc: 4, reg1: B },
            { id: 0xB1, cyc: 4, reg1: C },
            { id: 0xB2, cyc: 4, reg1: D },
            { id: 0xB3, cyc: 4, reg1: E },
            { id: 0xB4, cyc: 4, reg1: H },
            { id: 0xB5, cyc: 4, reg1: L },
            { id: 0xB6, cyc: 8, reg16_1: HL },
            { id: 0xB7, cyc: 4, reg1: A },
            { id: 0xB8, cyc: 4, reg1: B },
            { id: 0xB9, cyc: 4, reg1: C },
            { id: 0xBA, cyc: 4, reg1: D },
            { id: 0xBB, cyc: 4, reg1: E },
            { id: 0xBC, cyc: 4, reg1: H },
            { id: 0xBD, cyc: 4, reg1: L },
            { id: 0xBE, cyc: 8, reg16_1: HL },
            { id: 0xBF, cyc: 4, reg1: A },

            //ROW C
            { id: 0xC0, cyc: 8 },
            { id: 0xC1, cyc: 12, reg16_1: BC },
            { id: 0xC2, cyc: 12 },
            { id: 0xC3, cyc: 16 },
            { id: 0xC4, cyc: 12 },
            { id: 0xC5, cyc: 16, reg16_1: BC },
            { id: 0xC6, cyc: 8, immediate: true },
            { id: 0xC7, cyc: 16, address: 0x00 },
            { id: 0xC8, cyc: 8 },
            { id: 0xC9, cyc: 16 },
            { id: 0xCA, cyc: 12 },
            { id: 0xCB, cyc: 7 },
            { id: 0xCC, cyc: 12 },
            { id: 0xCD, cyc: 24 },
            { id: 0xCE, cyc: 8, immediate: true },
            { id: 0xCF, cyc: 16, address: 0x08 },

            //ROW D
            { id: 0xD0, cyc: 8 },
            { id: 0xD1, cyc: 12, reg16_1: DE },
            { id: 0xD2, cyc: 12 },
            { id: 0xD3, cyc: 7 },
            { id: 0xD4, cyc: 12 },
            { id: 0xD5, cyc: 16, reg16_1: DE },
            { id: 0xD6, cyc: 8, immediate: true },
            { id: 0xD7, cyc: 16, address: 0x10 },
            { id: 0xD8, cyc: 8 },
            { id: 0xD9, cyc: 16 },
            { id: 0xDA, cyc: 12 },
            { id: 0xDB, cyc: 7 },
            { id: 0xDC, cyc: 12 },
            { id: 0xDD, cyc: 7 },
            { id: 0xDE, cyc: 8, immediate: true },
            { id: 0xDF, cyc: 16, address: 0x18 },

            //ROW E
            { id: 0xE0, cyc: 12 },
            { id: 0xE1, cyc: 12, reg16_1: HL },
            { id: 0xE2, cyc: 8 },
            { id: 0xE3, cyc: 7 },
            { id: 0xE4, cyc: 7 },
            { id: 0xE5, cyc: 16, reg16_1: HL },
            { id: 0xE6, cyc: 8, immediate: true },
            { id: 0xE7, cyc: 16, address: 0x20 },
            { id: 0xE8, cyc: 16 },
            { id: 0xE9, cyc: 4 },
            { id: 0xEA, cyc: 16, reg1: A },
            { id: 0xEB, cyc: 7 },
            { id: 0xEC, cyc: 7 },
            { id: 0xED, cyc: 7 },
            { id: 0xEE, cyc: 8, immediate: true },
            { id: 0xEF, cyc: 16, address: 0x28 },

            //ROW F
            { id: 0xE0, cyc: 12, reg1: A },
            { id: 0xF1, cyc: 12, reg16_1: AF },
            { id: 0xE2, cyc: 8, reg1: A },
            { id: 0xF3, cyc: 4 },
            { id: 0xF4, cyc: 7 },
            { id: 0xF5, cyc: 16, reg16_1: AF },
            { id: 0xF6, cyc: 8, immediate: true },
            { id: 0xF7, cyc: 16, address: 0x30 },
            { id: 0xF8, cyc: 12 },
            { id: 0xF9, cyc: 8 },
            { id: 0xFA, cyc: 16, reg1: A },
            { id: 0xFB, cyc: 4 },
            { id: 0xFC, cyc: 7 },
            { id: 0xFD, cyc: 7 },
            { id: 0xFE, cyc: 8, immediate: true },
            { id: 0xFF, cyc: 16, address: 0x38 },



        ];

        this.cb_instructions = [

            //ROW 0
            { id: 0x00, cyc: 8, reg1: B },
            { id: 0x01, cyc: 8, reg1: C },
            { id: 0x02, cyc: 8, reg1: D },
            { id: 0x03, cyc: 8, reg1: E },
            { id: 0x04, cyc: 8, reg1: H },
            { id: 0x05, cyc: 8, reg1: L },
            { id: 0x06, cyc: 16, reg16_1: HL },
            { id: 0x07, cyc: 8, reg1: A },
            { id: 0x08, cyc: 8, reg1: B },
            { id: 0x09, cyc: 8, reg1: C },
            { id: 0x0A, cyc: 8, reg1: D },
            { id: 0x0B, cyc: 8, reg1: E },
            { id: 0x0C, cyc: 8, reg1: H },
            { id: 0x0D, cyc: 8, reg1: L },
            { id: 0x0E, cyc: 16, reg16_1: HL },
            { id: 0x0F, cyc: 8, reg1: A },

            //ROW 1
            { id: 0x10, cyc: 8, reg1: B },
            { id: 0x11, cyc: 8, reg1: C },
            { id: 0x12, cyc: 8, reg1: D },
            { id: 0x13, cyc: 8, reg1: E },
            { id: 0x14, cyc: 8, reg1: H },
            { id: 0x15, cyc: 8, reg1: L },
            { id: 0x16, cyc: 16, reg16_1: HL },
            { id: 0x17, cyc: 8, reg1: A },
            { id: 0x18, cyc: 8, reg1: B },
            { id: 0x19, cyc: 8, reg1: C },
            { id: 0x1A, cyc: 8, reg1: D },
            { id: 0x1B, cyc: 8, reg1: E },
            { id: 0x1C, cyc: 8, reg1: H },
            { id: 0x1D, cyc: 8, reg1: L },
            { id: 0x1E, cyc: 16, reg16_1: HL },
            { id: 0x1F, cyc: 8, reg1: A },

            //ROW 2
            { id: 0x20, cyc: 8, reg1: B },
            { id: 0x21, cyc: 8, reg1: C },
            { id: 0x22, cyc: 8, reg1: D },
            { id: 0x23, cyc: 8, reg1: E },
            { id: 0x24, cyc: 8, reg1: H },
            { id: 0x25, cyc: 8, reg1: L },
            { id: 0x26, cyc: 16, reg16_1: HL },
            { id: 0x27, cyc: 8, reg1: A },
            { id: 0x28, cyc: 8, reg1: B },
            { id: 0x29, cyc: 8, reg1: C },
            { id: 0x2A, cyc: 8, reg1: D },
            { id: 0x2B, cyc: 8, reg1: E },
            { id: 0x2C, cyc: 8, reg1: H },
            { id: 0x2D, cyc: 8, reg1: L },
            { id: 0x2E, cyc: 16, reg16_1: HL },
            { id: 0x2F, cyc: 8, reg1: A },

            //ROW 3
            { id: 0x30, cyc: 8, reg1: B },
            { id: 0x31, cyc: 8, reg1: C },
            { id: 0x32, cyc: 8, reg1: D },
            { id: 0x33, cyc: 8, reg1: E },
            { id: 0x34, cyc: 8, reg1: H },
            { id: 0x35, cyc: 8, reg1: L },
            { id: 0x36, cyc: 16, reg16_1: HL },
            { id: 0x37, cyc: 8, reg1: A },
            { id: 0x38, cyc: 8, reg1: B },
            { id: 0x39, cyc: 8, reg1: C },
            { id: 0x3A, cyc: 8, reg1: D },
            { id: 0x3B, cyc: 8, reg1: E },
            { id: 0x3C, cyc: 8, reg1: H },
            { id: 0x3D, cyc: 8, reg1: L },
            { id: 0x3E, cyc: 16, reg16_1: HL },
            { id: 0x3F, cyc: 8, reg1: A },

            //ROW 4
            { id: 0x40, cyc: 8, reg1: B, bit: 0 },
            { id: 0x41, cyc: 8, reg1: C, bit: 0 },
            { id: 0x42, cyc: 8, reg1: D, bit: 0 },
            { id: 0x43, cyc: 8, reg1: E, bit: 0 },
            { id: 0x44, cyc: 8, reg1: H, bit: 0 },
            { id: 0x45, cyc: 8, reg1: L, bit: 0 },
            { id: 0x46, cyc: 12, reg16_1: HL, bit: 0 },
            { id: 0x47, cyc: 8, reg1: A, bit: 0 },
            { id: 0x48, cyc: 8, reg1: B, bit: 1 },
            { id: 0x49, cyc: 8, reg1: C, bit: 1 },
            { id: 0x4A, cyc: 8, reg1: D, bit: 1 },
            { id: 0x4B, cyc: 8, reg1: E, bit: 1 },
            { id: 0x4C, cyc: 8, reg1: H, bit: 1 },
            { id: 0x4D, cyc: 8, reg1: L, bit: 1 },
            { id: 0x4E, cyc: 12, reg16_1: HL, bit: 1 },
            { id: 0x4F, cyc: 8, reg1: A, bit: 1 },

            //ROW 5
            { id: 0x50, cyc: 8, reg1: B, bit: 2 },
            { id: 0x51, cyc: 8, reg1: C, bit: 2 },
            { id: 0x52, cyc: 8, reg1: D, bit: 2 },
            { id: 0x53, cyc: 8, reg1: E, bit: 2 },
            { id: 0x54, cyc: 8, reg1: H, bit: 2 },
            { id: 0x55, cyc: 8, reg1: L, bit: 2 },
            { id: 0x56, cyc: 12, reg16_1: HL, bit: 2 },
            { id: 0x57, cyc: 8, reg1: A, bit: 2 },
            { id: 0x58, cyc: 8, reg1: B, bit: 3 },
            { id: 0x59, cyc: 8, reg1: C, bit: 3 },
            { id: 0x5A, cyc: 8, reg1: D, bit: 3 },
            { id: 0x5B, cyc: 8, reg1: E, bit: 3 },
            { id: 0x5C, cyc: 8, reg1: H, bit: 3 },
            { id: 0x5D, cyc: 8, reg1: L, bit: 3 },
            { id: 0x5E, cyc: 12, reg16_1: HL, bit: 3 },
            { id: 0x5F, cyc: 8, reg1: A, bit: 3 },

            //ROW 6
            { id: 0x60, cyc: 8, reg1: B, bit: 4 },
            { id: 0x61, cyc: 8, reg1: C, bit: 4 },
            { id: 0x62, cyc: 8, reg1: D, bit: 4 },
            { id: 0x63, cyc: 8, reg1: E, bit: 4 },
            { id: 0x64, cyc: 8, reg1: H, bit: 4 },
            { id: 0x65, cyc: 8, reg1: L, bit: 4 },
            { id: 0x66, cyc: 12, reg16_1: HL, bit: 4 },
            { id: 0x67, cyc: 8, reg1: A, bit: 4 },
            { id: 0x68, cyc: 8, reg1: B, bit: 5 },
            { id: 0x69, cyc: 8, reg1: C, bit: 5 },
            { id: 0x6A, cyc: 8, reg1: D, bit: 5 },
            { id: 0x6B, cyc: 8, reg1: E, bit: 5 },
            { id: 0x6C, cyc: 8, reg1: H, bit: 5 },
            { id: 0x6D, cyc: 8, reg1: L, bit: 5 },
            { id: 0x6E, cyc: 12, reg16_1: HL, bit: 5 },
            { id: 0x6F, cyc: 8, reg1: A, bit: 5 },

            //ROW 7
            { id: 0x70, cyc: 8, reg1: B, bit: 6 },
            { id: 0x71, cyc: 8, reg1: C, bit: 6 },
            { id: 0x72, cyc: 8, reg1: D, bit: 6 },
            { id: 0x73, cyc: 8, reg1: E, bit: 6 },
            { id: 0x74, cyc: 8, reg1: H, bit: 6 },
            { id: 0x75, cyc: 8, reg1: L, bit: 6 },
            { id: 0x76, cyc: 12, reg16_1: HL, bit: 6 },
            { id: 0x77, cyc: 8, reg1: A, bit: 6 },
            { id: 0x78, cyc: 8, reg1: B, bit: 7 },
            { id: 0x79, cyc: 8, reg1: C, bit: 7 },
            { id: 0x7A, cyc: 8, reg1: D, bit: 7 },
            { id: 0x7B, cyc: 8, reg1: E, bit: 7 },
            { id: 0x7C, cyc: 8, reg1: H, bit: 7 },
            { id: 0x7D, cyc: 8, reg1: L, bit: 7 },
            { id: 0x7E, cyc: 12, reg16_1: HL, bit: 7 },
            { id: 0x7F, cyc: 8, reg1: A, bit: 7 },

            //ROW 8
            { id: 0x80, cyc: 8, reg1: B, bit: 0 },
            { id: 0x81, cyc: 8, reg1: C, bit: 0 },
            { id: 0x82, cyc: 8, reg1: D, bit: 0 },
            { id: 0x83, cyc: 8, reg1: E, bit: 0 },
            { id: 0x84, cyc: 8, reg1: H, bit: 0 },
            { id: 0x85, cyc: 8, reg1: L, bit: 0 },
            { id: 0x86, cyc: 16, reg16_1: HL, bit: 0 },
            { id: 0x87, cyc: 8, reg1: A, bit: 0 },
            { id: 0x88, cyc: 8, reg1: B, bit: 1 },
            { id: 0x89, cyc: 8, reg1: C, bit: 1 },
            { id: 0x8A, cyc: 8, reg1: D, bit: 1 },
            { id: 0x8B, cyc: 8, reg1: E, bit: 1 },
            { id: 0x8C, cyc: 8, reg1: H, bit: 1 },
            { id: 0x8D, cyc: 8, reg1: L, bit: 1 },
            { id: 0x8E, cyc: 16, reg16_1: HL, bit: 1 },
            { id: 0x8F, cyc: 8, reg1: A, bit: 1 },

            //ROW 9
            { id: 0x90, cyc: 8, reg1: B, bit: 2 },
            { id: 0x91, cyc: 8, reg1: C, bit: 2 },
            { id: 0x92, cyc: 8, reg1: D, bit: 2 },
            { id: 0x93, cyc: 8, reg1: E, bit: 2 },
            { id: 0x94, cyc: 8, reg1: H, bit: 2 },
            { id: 0x95, cyc: 8, reg1: L, bit: 2 },
            { id: 0x96, cyc: 16, reg16_1: HL, bit: 2 },
            { id: 0x97, cyc: 8, reg1: A, bit: 2 },
            { id: 0x98, cyc: 8, reg1: B, bit: 3 },
            { id: 0x99, cyc: 8, reg1: C, bit: 3 },
            { id: 0x9A, cyc: 8, reg1: D, bit: 3 },
            { id: 0x9B, cyc: 8, reg1: E, bit: 3 },
            { id: 0x9C, cyc: 8, reg1: H, bit: 3 },
            { id: 0x9D, cyc: 8, reg1: L, bit: 3 },
            { id: 0x9E, cyc: 16, reg16_1: HL, bit: 3 },
            { id: 0x9F, cyc: 8, reg1: A, bit: 3 },

            //ROW A
            { id: 0xA0, cyc: 8, reg1: B, bit: 4 },
            { id: 0xA1, cyc: 8, reg1: C, bit: 4 },
            { id: 0xA2, cyc: 8, reg1: D, bit: 4 },
            { id: 0xA3, cyc: 8, reg1: E, bit: 4 },
            { id: 0xA4, cyc: 8, reg1: H, bit: 4 },
            { id: 0xA5, cyc: 8, reg1: L, bit: 4 },
            { id: 0xA6, cyc: 16, reg16_1: HL, bit: 4 },
            { id: 0xA7, cyc: 8, reg1: A, bit: 4 },
            { id: 0xA8, cyc: 8, reg1: B, bit: 5 },
            { id: 0xA9, cyc: 8, reg1: C, bit: 5 },
            { id: 0xAA, cyc: 8, reg1: D, bit: 5 },
            { id: 0xAB, cyc: 8, reg1: E, bit: 5 },
            { id: 0xAC, cyc: 8, reg1: H, bit: 5 },
            { id: 0xAD, cyc: 8, reg1: L, bit: 5 },
            { id: 0xAE, cyc: 16, reg16_1: HL, bit: 5 },
            { id: 0xAF, cyc: 8, reg1: A, bit: 5 },

            //ROW B
            { id: 0xB0, cyc: 8, reg1: B, bit: 6 },
            { id: 0xB1, cyc: 8, reg1: C, bit: 6 },
            { id: 0xB2, cyc: 8, reg1: D, bit: 6 },
            { id: 0xB3, cyc: 8, reg1: E, bit: 6 },
            { id: 0xB4, cyc: 8, reg1: H, bit: 6 },
            { id: 0xB5, cyc: 8, reg1: L, bit: 6 },
            { id: 0xB6, cyc: 16, reg16_1: HL, bit: 6 },
            { id: 0xB7, cyc: 8, reg1: A, bit: 6 },
            { id: 0xB8, cyc: 8, reg1: B, bit: 7 },
            { id: 0xB9, cyc: 8, reg1: C, bit: 7 },
            { id: 0xBA, cyc: 8, reg1: D, bit: 7 },
            { id: 0xBB, cyc: 8, reg1: E, bit: 7 },
            { id: 0xBC, cyc: 8, reg1: H, bit: 7 },
            { id: 0xBD, cyc: 8, reg1: L, bit: 7 },
            { id: 0xBE, cyc: 16, reg16_1: HL, bit: 7 },
            { id: 0xBF, cyc: 8, reg1: A, bit: 7 },

            //ROW C
            { id: 0xC0, cyc: 8, reg1: B, bit: 0 },
            { id: 0xC1, cyc: 8, reg1: C, bit: 0 },
            { id: 0xC2, cyc: 8, reg1: D, bit: 0 },
            { id: 0xC3, cyc: 8, reg1: E, bit: 0 },
            { id: 0xC4, cyc: 8, reg1: H, bit: 0 },
            { id: 0xC5, cyc: 8, reg1: L, bit: 0 },
            { id: 0xC6, cyc: 16, reg16_1: HL, bit: 0 },
            { id: 0xC7, cyc: 8, reg1: A, bit: 0 },
            { id: 0xC8, cyc: 8, reg1: B, bit: 1 },
            { id: 0xC9, cyc: 8, reg1: C, bit: 1 },
            { id: 0xCA, cyc: 8, reg1: D, bit: 1 },
            { id: 0xCB, cyc: 8, reg1: E, bit: 1 },
            { id: 0xCC, cyc: 8, reg1: H, bit: 1 },
            { id: 0xCD, cyc: 8, reg1: L, bit: 1 },
            { id: 0xCE, cyc: 16, reg16_1: HL, bit: 1 },
            { id: 0xCF, cyc: 8, reg1: A, bit: 1 },

            //ROW D
            { id: 0xD0, cyc: 8, reg1: B, bit: 2 },
            { id: 0xD1, cyc: 8, reg1: C, bit: 2 },
            { id: 0xD2, cyc: 8, reg1: D, bit: 2 },
            { id: 0xD3, cyc: 8, reg1: E, bit: 2 },
            { id: 0xD4, cyc: 8, reg1: H, bit: 2 },
            { id: 0xD5, cyc: 8, reg1: L, bit: 2 },
            { id: 0xD6, cyc: 16, reg16_1: HL, bit: 2 },
            { id: 0xD7, cyc: 8, reg1: A, bit: 2 },
            { id: 0xD8, cyc: 8, reg1: B, bit: 3 },
            { id: 0xD9, cyc: 8, reg1: C, bit: 3 },
            { id: 0xDA, cyc: 8, reg1: D, bit: 3 },
            { id: 0xDB, cyc: 8, reg1: E, bit: 3 },
            { id: 0xDC, cyc: 8, reg1: H, bit: 3 },
            { id: 0xDD, cyc: 8, reg1: L, bit: 3 },
            { id: 0xDE, cyc: 16, reg16_1: HL, bit: 3 },
            { id: 0xDF, cyc: 8, reg1: A, bit: 3 },

            //ROW E
            { id: 0xE0, cyc: 8, reg1: B, bit: 4 },
            { id: 0xE1, cyc: 8, reg1: C, bit: 4 },
            { id: 0xE2, cyc: 8, reg1: D, bit: 4 },
            { id: 0xE3, cyc: 8, reg1: E, bit: 4 },
            { id: 0xE4, cyc: 8, reg1: H, bit: 4 },
            { id: 0xE5, cyc: 8, reg1: L, bit: 4 },
            { id: 0xE6, cyc: 16, reg16_1: HL, bit: 4 },
            { id: 0xE7, cyc: 8, reg1: A, bit: 4 },
            { id: 0xE8, cyc: 8, reg1: B, bit: 5 },
            { id: 0xE9, cyc: 8, reg1: C, bit: 5 },
            { id: 0xEA, cyc: 8, reg1: D, bit: 5 },
            { id: 0xEB, cyc: 8, reg1: E, bit: 5 },
            { id: 0xEC, cyc: 8, reg1: H, bit: 5 },
            { id: 0xED, cyc: 8, reg1: L, bit: 5 },
            { id: 0xEE, cyc: 16, reg16_1: HL, bit: 5 },
            { id: 0xEF, cyc: 8, reg1: A, bit: 5 },

            //ROW F
            { id: 0xF0, cyc: 8, reg1: B, bit: 6 },
            { id: 0xF1, cyc: 8, reg1: C, bit: 6 },
            { id: 0xF2, cyc: 8, reg1: D, bit: 6 },
            { id: 0xF3, cyc: 8, reg1: E, bit: 6 },
            { id: 0xF4, cyc: 8, reg1: H, bit: 6 },
            { id: 0xF5, cyc: 8, reg1: L, bit: 6 },
            { id: 0xF6, cyc: 16, reg16_1: HL, bit: 6 },
            { id: 0xF7, cyc: 8, reg1: A, bit: 6 },
            { id: 0xF8, cyc: 8, reg1: B, bit: 7 },
            { id: 0xF9, cyc: 8, reg1: C, bit: 7 },
            { id: 0xFA, cyc: 8, reg1: D, bit: 7 },
            { id: 0xFB, cyc: 8, reg1: E, bit: 7 },
            { id: 0xFC, cyc: 8, reg1: H, bit: 7 },
            { id: 0xFD, cyc: 8, reg1: L, bit: 7 },
            { id: 0xFE, cyc: 16, reg16_1: HL, bit: 7 },
            { id: 0xFF, cyc: 8, reg1: A, bit: 7 },



        ];

    }


    //cpu reset function sets the cpu to a known state
    reset() {

        //need this otherwise pokemon puzzle league
        //breaks when calling reset() a second time
        for (let i = 0; i < this.gameboy.memory.ram.length; i++)
            this.gameboy.memory.ram[i] = 0;

        //TODO lots of other stuff to reset as well to get it to a truly fresh state
        //TODO set it to the post-BIOS values

        this.halt_mode = false;
        this.stop_mode = false;
        this.IME = false;
        this.IE = 0;
        this.IF = 0;
        this.TIMER_DIV = 0;
        this.TIMER_TIMA = 0;
        this.TIMER_TMA = 0;
        this.TIMER_TAC = 0;

        //is this correct?
        this.A = 0;
        this.B = 0;
        this.C = 0;
        this.D = 0;
        this.E = 0;
        this.F = 0;
        this.H = 0;
        this.L = 0;

        //my own variables
        this.address = 0;
        this.speedmode = 0;

        //change this later to 0x00 to load the bios
        this.PC = 0x100;

        //stack pointer should I reset this to 0xFFFE?
        this.SP = 0xFFFE;

        //Gameboy Color State
        if (this.gameboy.memory.color_gb) {
            this.gameboy.cpu.A = 0x11;
            this.gameboy.cpu.F = 0xB0;
            this.gameboy.cpu.B = 0x00;
            this.gameboy.cpu.C = 0x13;
            this.gameboy.cpu.D = 0x00;
            this.gameboy.cpu.E = 0xD8;
            this.gameboy.cpu.H = 0x01;
            this.gameboy.cpu.L = 0x4D;
            this.gameboy.memory.ram[0xFF6C] = 0xFE;
            this.gameboy.memory.ram[0xFF74] = 0xFE;
        }

    }


    /* HELPER FUNCTIONS */

    read(address: number) {
        return this.gameboy.memory.read(address);
    }

    write(address: number, value: number) {
        this.gameboy.memory.write(address, value);
    }

    //mask a number to 8 bits
    //since javascript only has floating point numbers
    mask255(data: number): number {
        return data & 0xFF;
    }

    getFlag(flag: number): number {
        if (this.F & (1 << flag))
            return 1;
        else
            return 0;
    }

    //value should be 0 or 1
    setFlag(flag: number, value: number) {
        this.F = this.setBit(this.F, flag, value);
    }

    getBit(byte: number, bit: number): number {
        return (byte >> bit) & 1;
    }

    setBit(byte: number, bit: number, value: number): number {
        if (value > 0)
            return byte | (1 << bit);
        else
            return byte & ~(1 << bit);
    }

    toggleBit(byte: number, bit: number): number {
        return byte ^ (1 << bit);
    }

    getInstruction(opcode: number): Instruction {
        return this.all_instructions[opcode];
    }

    setReg(reg: number, value: number) {
        this._regs[reg] = this.mask255(value);
    }

    setReg16(reg16: any, val: number) {
        this._regs[reg16.reg1 as number] = this.mask255(this.getHighNibble(val));
        this._regs[reg16.reg2 as number] = this.mask255(this.getLowNibble(val));
    }

    getReg(reg: number) {
        return this._regs[reg];
    }

    getReg16(reg16: any): number {
        return (this.getReg(reg16.reg1) << 8) + this.getReg(reg16.reg2);
    }

    convertTwo8sto16(high: number, low: number): number {
        return (high << 8) + low;
    }

    getHighNibble(val: number): number {
        return this.mask255(val >> 8);
    }

    getLowNibble(val: number): number {
        return val & 0xFF;
    }

    //returns true if the lower nibbles 
    //of the 2 values added together
    //causes a carry into bit 4
    //example 5+11=16 which would yield true
    //but 5+10=15 which would yield false
    //reversed for subtraction example -
    //getHalfCarry(86,6,true) would yield false
    //getHalfCarry(85,6,true) would yield true
    getHalfCarry(val1: number, val2: number, isSubtract: boolean = false,
        additional_carry = 0): number {
        if (isSubtract == false)
            return (((val1 & 0x0F) + (val2 & 0x0F) + additional_carry) & 0x10);
        else
            return (((val1 & 0x0F) - (val2 & 0x0F) - additional_carry) & 0x10);
    }

    //treats byte as signed and returns
    //either positive or negative number from -128 to 127
    //example: 251 would be -5
    getSignedByteValue(byte: number): number {
        if (byte >= 128)
            return byte - 256;
        else
            return byte;
    }

    setFlagsZ(value: number) {

        let maskedValue = this.mask255(value);
        //set the zero flag if the value is zero
        if (maskedValue == 0)
            this.setFlag(FLAG_Z, 1);
        else
            this.setFlag(FLAG_Z, 0);

    }



    /* INSTRUCTIONS */
    //https://www.pastraiser.com/cpu/gameboy/gameboy_opcodes.html

    XXX(ins: any) {
        //not yet implemented
        console.log('XXX Instruction');
    }

    ILL(ins: any) {
        //illegal opcode
        console.log('Illegal Instruction');
        this.gameboy.PAUSED = true;
    }

    NOP(ins: any) {
        //do nothing
    }

    //JP Z,a16
    //Jump if zero
    JumpZ(ins: any) {
        if (!this.getFlag(FLAG_Z)) {
            this.PC += 2;
            return;
        }
        this.JumpImmediate(ins);
        this.cycles += 4;
    }

    //JP NZ,a16
    //Jump if not zero
    JumpNZ(ins: any) {
        if (this.getFlag(FLAG_Z)) {
            this.PC += 2;
            return;
        }
        this.JumpImmediate(ins);
        this.cycles += 4;
    }

    //JP C,a16
    //Jump if carry
    JumpC(ins: any) {
        if (!this.getFlag(FLAG_C)) {
            this.PC += 2;
            return;
        }
        this.JumpImmediate(ins);
        this.cycles += 4;
    }

    //JP NC,a16
    //Jump if not carry
    JumpNC(ins: any) {
        if (this.getFlag(FLAG_C)) {
            this.PC += 2;
            return;
        }
        this.JumpImmediate(ins);
        this.cycles += 4;
    }

    // JP a16
    //Jump
    JumpImmediate(ins: any) {
        this.address = this.read(this.PC) + (this.read(this.PC + 1) << 8);
        this.PC = this.address;
    }

    // JR r8
    JumpRelative(ins: any) {
        let jump_amount = this.read(this.PC);
        this.PC += this.getSignedByteValue(jump_amount) + 1;
    }

    // JR NZ,r8
    JumpRelativeNZ(ins: any) {
        if (this.getFlag(FLAG_Z)) {
            this.PC += 1;
            return;
        }
        this.cycles += 4;
        this.JumpRelative(ins);
    }

    // JR NC,r8
    JumpRelativeNC(ins: any) {
        if (this.getFlag(FLAG_C)) {
            this.PC += 1;
            return;
        }
        this.cycles += 4;
        this.JumpRelative(ins);
    }

    // JR Z,r8
    JumpRelativeZ(ins: any) {
        if (!this.getFlag(FLAG_Z)) {
            this.PC += 1;
            return;
        }
        this.cycles += 4;
        this.JumpRelative(ins);
    }

    // JR C,r8
    JumpRelativeC(ins: any) {
        if (!this.getFlag(FLAG_C)) {
            this.PC += 1;
            return;
        }
        this.cycles += 4;
        this.JumpRelative(ins);
    }

    // JP (HL)
    JumpHL(ins: any) {
        let address = this.getReg16(HL);
        this.PC = address;
    }

    //add with carry
    //add in the carry bit as part of the add operation
    ADC(ins: any) {
        this.ADD(ins, true);
    }

    // ADD A,B
    //add with carry if adc parameter true
    ADD(ins: any, adc = false) {
        let reg1 = this.A;
        let reg2 = 0;

        if (ins.reg1 == 0 || ins.reg1) {
            //coming from 8 bit register
            reg2 = this.getReg(ins.reg1);
        }
        else if (ins.immediate) {
            //coming from immediate byte
            reg2 = this.read(this.PC);
            this.PC++;
        }
        else {
            //coming from HL
            let address = this.getReg16(HL);
            reg2 = this.read(address);
        }

        let temp = reg1 + reg2;
        if (adc)
            temp += this.getFlag(FLAG_C);

        //set the zero flag
        this.setFlagsZ(temp);

        //set the subtraction flag
        this.setFlag(FLAG_N, 0);

        //set the half carry bit
        let additional_carry = 0;
        if (adc)
            additional_carry = this.getFlag(FLAG_C);
        this.halfcarry = this.getHalfCarry(reg1, reg2, false, additional_carry);

        //set the carry bit 
        this.setFlag(FLAG_C, temp > 255 ? 1 : 0);

        this.setFlag(FLAG_H, this.halfcarry);

        //load the value back into the accumulator
        this.A = temp;
    }

    //subtract with carry
    SBC(ins: any) {
        this.SUB(ins, true);
    }

    // SUB B
    SUB(ins: any, sbc = false) {
        let reg1 = this.A;
        let reg2 = 0;

        if (ins.reg1 == 0 || ins.reg1) {
            //coming from 8 bit register
            reg2 = this.getReg(ins.reg1);
        }
        else if (ins.immediate) {
            //coming from immediate byte
            reg2 = this.read(this.PC);
            this.PC++;
        }
        else {
            //coming from HL
            let address = this.getReg16(HL);
            reg2 = this.read(address);
        }

        let temp = reg1 - reg2;
        if (sbc)
            temp -= this.getFlag(FLAG_C);

        //set the zero flag
        this.setFlagsZ(temp);

        //set the subtraction flag
        this.setFlag(FLAG_N, 1);

        //set the half carry bit
        let additional_carry = 0;
        if (sbc)
            additional_carry = this.getFlag(FLAG_C);
        this.halfcarry = this.getHalfCarry(reg1, reg2, true, additional_carry);
        this.setFlag(FLAG_H, this.halfcarry);

        //set the carry bit 
        this.setFlag(FLAG_C, temp < 0 ? 1 : 0);

        if (temp < 0) {
            temp = 256 - Math.abs(temp)
        }

        //load the value back into the accumulator
        this.A = temp;
    }

    // AND B
    AND(ins: any) {
        let reg1 = this.A;
        let reg2 = 0;

        if (ins.reg1 == 0 || ins.reg1) {
            //coming from 8 bit register
            reg2 = this.getReg(ins.reg1);
        }
        else if (ins.immediate) {
            //coming from immediate byte
            reg2 = this.read(this.PC);
            this.PC++;
        }
        else {
            //coming from HL
            let address = this.getReg16(HL);
            reg2 = this.read(address);
        }

        let temp = reg1 & reg2;

        //set the zero flag
        this.setFlagsZ(temp);

        this.setFlag(FLAG_N, 0);
        this.setFlag(FLAG_H, 1);
        this.setFlag(FLAG_C, 0);

        //load the value back into the accumulator
        this.A = temp;
    }

    // XOR B
    XOR(ins: any) {
        let reg1 = this.A;
        let reg2 = 0;

        if (ins.reg1 == 0 || ins.reg1) {
            //coming from 8 bit register
            reg2 = this.getReg(ins.reg1);
        }
        else if (ins.immediate) {
            //coming from immediate byte
            reg2 = this.read(this.PC);
            this.PC++;
        }
        else {
            //coming from HL
            let address = this.getReg16(HL);
            reg2 = this.read(address);
        }

        let temp = reg1 ^ reg2;

        //set the zero flag
        this.setFlagsZ(temp);

        this.setFlag(FLAG_N, 0);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_C, 0);

        //load the value back into the accumulator
        this.A = temp;
    }

    // OR B
    OR(ins: any) {
        let reg1 = this.A;
        let reg2 = 0;

        if (ins.reg1 == 0 || ins.reg1) {
            //coming from 8 bit register
            reg2 = this.getReg(ins.reg1);
        }
        else if (ins.immediate) {
            //coming from immediate byte
            reg2 = this.read(this.PC);
            this.PC++;
        }
        else {
            //coming from HL
            let address = this.getReg16(HL);
            reg2 = this.read(address);
        }

        let temp = reg1 | reg2;

        //set the zero flag
        this.setFlagsZ(temp);

        this.setFlag(FLAG_N, 0);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_C, 0);

        //load the value back into the accumulator
        this.A = temp;
    }

    // CP B
    //Compare A to B
    //Do A - B, throw out the results, and set the flags
    CP(ins: any) {
        let reg1 = this.A;
        let reg2 = 0;

        if (ins.reg1 == 0 || ins.reg1) {
            //coming from 8 bit register
            reg2 = this.getReg(ins.reg1);
        }
        else if (ins.immediate) {
            //coming from immediate byte
            reg2 = this.read(this.PC);
            this.PC++;
        }
        else {
            //coming from HL
            let address = this.getReg16(HL);
            reg2 = this.read(address);
        }

        let temp = reg1 - reg2;

        //set the zero flag
        this.setFlagsZ(temp);

        this.setFlag(FLAG_N, 1);

        let halfcarry = this.getHalfCarry(reg1, reg2, true);
        this.setFlag(FLAG_H, halfcarry);

        this.setFlag(FLAG_C, temp < 0 ? 1 : 0);
    }



    //INC (HL)
    //increment what HL is pointing at
    INC16HL(ins: any) {
        let address = this.getReg16(HL);
        let value = this.read(address);
        let result = this.mask255(value + 1);
        this.halfcarry = this.getHalfCarry(value, 1);
        this.setFlag(FLAG_H, this.halfcarry);
        this.setFlag(FLAG_N, 0);
        this.setFlagsZ(result);
        this.write(address, result);
    }

    //DEC (HL)
    //decrement what HL is pointing at
    DEC16HL(ins: any) {
        let address = this.getReg16(HL);
        let value = this.read(address);
        let result = this.mask255(value - 1);
        this.halfcarry = this.getHalfCarry(value, 1, true);
        this.setFlag(FLAG_H, this.halfcarry);
        this.setFlag(FLAG_N, 1);
        this.setFlagsZ(result);
        this.write(address, result);
    }

    //example INC BC - increment BC
    INC16(ins: any) {
        if (ins.reg16_1 == SP) {
            this.SP++;
        } else {
            if (this.getReg(ins.reg16_1.reg2) == 255) {
                this.setReg(ins.reg16_1.reg1, this.getReg(ins.reg16_1.reg1) + 1);
            }
            //this is slower
            // this.setReg(ins.reg16_1.reg2,this.getReg(ins.reg16_1.reg2)+1);
            let reg16 = ins.reg16_1;
            let reg2 = reg16["reg2"] as number;
            this._regs[reg2] = this.mask255(this._regs[reg2] + 1);
        }

    }

    // DEC BC
    DEC16(ins: any) {
        if (ins.reg16_1 == SP) {
            this.SP--;
        } else {
            if (this.getReg(ins.reg16_1.reg2) == 0) {
                this.setReg(ins.reg16_1.reg1, this.getReg(ins.reg16_1.reg1) - 1);
            }
            //this is slower
            // this.setReg(ins.reg16_1.reg2,this.getReg(ins.reg16_1.reg2)-1);
            let reg16 = ins.reg16_1;
            let reg2 = reg16["reg2"] as number;
            this._regs[reg2]--;
            if (this._regs[reg2] < 0) {
                this._regs[reg2] = 255;
            }
        }
    }

    // INC B
    INC8(ins: any) {
        let reg1 = this.getReg(ins.reg1);
        let result = reg1 + 1;
        this.halfcarry = this.getHalfCarry(reg1, 1);
        this.setFlag(FLAG_H, this.halfcarry);
        this.setFlag(FLAG_N, 0);
        this.setFlagsZ(result);
        this.setReg(ins.reg1, result);
    }

    // DEC D
    DEC8(ins: any) {
        let reg1 = this.getReg(ins.reg1);
        let result = reg1 - 1;
        this.halfcarry = this.getHalfCarry(reg1, 1, true);
        this.setFlag(FLAG_H, this.halfcarry);
        this.setFlag(FLAG_N, 1);
        this.setFlagsZ(result);
        this.setReg(ins.reg1, result);
    }

    //example ld a, 5 -> load A with 5
    LoadReg8Immediate(ins: any) {
        this.setReg(ins.reg1, this.read(this.PC));
        this.PC++;
    }

    //example LD BC,500 -> loads BC with value 500
    LoadReg16Immediate(ins: any) {
        let lownibble = this.read(this.PC);
        let highnibble = this.read(this.PC + 1);
        this.PC += 2;
        this.setReg(ins.reg16_1.reg1, highnibble);
        this.setReg(ins.reg16_1.reg2, lownibble);
    }

    //example LD (BC), A -> Loads the address at BC with A
    LoadMemFromReg8(ins: any) {
        this.address = this.getReg16(ins.reg16_1);
        this.write(this.address, this.getReg(ins.reg1));
    }

    //example LD (HL),d8
    LoadMemImmediate(ins: any) {
        this.address = this.getReg16(ins.reg16_1);
        let value = this.read(this.PC);
        this.PC++;
        this.write(this.address, value);
    }

    //example LD (HL),d8
    LoadMemImmediateFromReg8(ins: any) {
        let low = this.read(this.PC);
        let high = this.read(this.PC + 1);
        this.PC += 2;
        this.address = this.convertTwo8sto16(high, low);
        this.write(this.address, this.getReg(ins.reg1));
    }

    //example (HL+), A -> Loads the address at HL with A
    //then increments HL
    LoadMemFromReg8Increment(ins: any) {
        this.LoadMemFromReg8(ins);
        this.INC16(ins);
    }

    //example (HL-), A -> Loads the address at HL with A
    //then decrements HL
    LoadMemFromReg8Decrement(ins: any) {
        this.LoadMemFromReg8(ins);
        this.DEC16(ins);
    }

    //LD A,(BC)
    LoadReg8FromMem(ins: any) {
        let value = this.read(this.getReg16(ins.reg16_1));
        this.setReg(ins.reg1, value);
    }

    //LD A,(HL+) -> Load register then incremement address
    LoadReg8FromMemIncrement(ins: any) {
        let value = this.read(this.getReg16(ins.reg16_1));
        this.setReg(ins.reg1, value);
        this.INC16(ins);
    }

    //LD A,(HL-) -> Load register then decrement address
    LoadReg8FromMemDecrement(ins: any) {
        let value = this.read(this.getReg16(ins.reg16_1));
        this.setReg(ins.reg1, value);
        this.DEC16(ins);
    }

    //LD A,(a16)
    LoadReg8FromMemImmediate(ins: any) {
        let low = this.read(this.PC);
        let high = this.read(this.PC + 1);
        let value = this.read(this.convertTwo8sto16(high, low));
        this.setReg(ins.reg1, value);
        this.PC += 2;
    }

    // LD B,B
    LoadReg8FromReg8(ins: any) {
        this.setReg(ins.reg1, this.getReg(ins.reg2));
    }

    /* STACK FUNCTIONS */

    //LD (a16),SP
    //write the 2 byte value of the stack pointer
    //to the provided memory location
    StackCopyToMem(ins: any) {
        let low = this.read(this.PC);
        let high = this.read(this.PC + 1);
        this.address = this.convertTwo8sto16(high, low);
        this.write(this.address, this.getLowNibble(this.SP));
        this.write(this.address + 1, this.getHighNibble(this.SP));
        this.PC += 2;
    }

    //LD SP,d16
    //set the stack pointer to a 2 byte immediate value
    StackLoadImmediate(ins: any) {
        let low = this.read(this.PC);
        let high = this.read(this.PC + 1);
        let val = this.convertTwo8sto16(high, low);
        this.SP = val;
        this.PC += 2;
    }

    //RLCA - rotate left and the bit 7 wraps around
    RLCA(ins: any) {
        let data = this._regs[ins.reg1 as number];
        let bit7 = this.getBit(data, 7);
        this._regs[ins.reg1 as number] = this.mask255((data << 1) + bit7);
        this.setFlag(FLAG_C, bit7);
        this.setFlag(FLAG_Z, 0);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
    }

    //RLA - rotate left and the carry bit wraps around
    RLA(ins: any) {
        let data = this._regs[ins.reg1 as number];
        let bit7 = this.getBit(data, 7);
        this._regs[ins.reg1 as number] = this.mask255((data << 1) + this.getFlag(FLAG_C));
        this.setFlag(FLAG_C, bit7);
        this.setFlag(FLAG_Z, 0);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
    }

    //RRCA - rotate right and the bit 0 wraps around
    RRCA(ins: any) {
        let data = this._regs[ins.reg1 as number];
        let bit1 = this.getBit(data, 0);
        this._regs[ins.reg1 as number] = this.mask255((data >> 1) + (bit1 << 7));
        this.setFlag(FLAG_C, bit1);
        this.setFlag(FLAG_Z, 0);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
    }

    //RRA - rotate right and the carry bit wraps around
    RRA(ins: any) {
        let data = this._regs[ins.reg1 as number];
        let bit1 = this.getBit(data, 0);
        this._regs[ins.reg1 as number] = this.mask255((data >> 1) + (this.getFlag(FLAG_C) << 7));
        this.setFlag(FLAG_C, bit1);
        this.setFlag(FLAG_Z, 0);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
    }

    //CB Rotate Opcodes

    // RLC B
    // Rotate n left. Old bit 7 to Carry flag.
    RLC(ins: any) {
        let data = 0;
        let isHL = false;
        if (ins.reg16_1)
            isHL = true;
        if (isHL == false)
            data = this._regs[ins.reg1 as number];
        else {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        let bit7 = this.getBit(data, 7);
        let result = (data << 1) + bit7;
        this.setFlag(FLAG_C, bit7);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
        this.setFlagsZ(result);
        if (isHL == false)
            this.setReg(ins.reg1, result);
        else
            this.write(this.address, result);
    }

    // RRC B
    // Rotate n right. Old bit 0 to Carry flag.
    RRC(ins: any) {
        let data = 0;
        let isHL = false;
        if (ins.reg16_1)
            isHL = true;
        if (isHL == false)
            data = this._regs[ins.reg1 as number];
        else {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        let bit0 = this.getBit(data, 0);
        let result = (data >> 1) + (bit0 << 7);
        this.setFlag(FLAG_C, bit0);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
        this.setFlagsZ(result);
        if (isHL == false)
            this.setReg(ins.reg1, result);
        else
            this.write(this.address, result);
    }

    // RL C
    // Rotate n left through Carry flag.
    RL(ins: any) {
        let data = 0;
        let isHL = false;
        if (ins.reg16_1)
            isHL = true;
        if (isHL == false)
            data = this._regs[ins.reg1 as number];
        else {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        let bit7 = this.getBit(data, 7);
        let result = (data << 1) + this.getFlag(FLAG_C);
        this.setFlag(FLAG_C, bit7);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
        this.setFlagsZ(result);
        if (isHL == false)
            this.setReg(ins.reg1, result);
        else
            this.write(this.address, result);
    }

    // RR C
    // Rotate n right through Carry flag.
    RR(ins: any) {
        let data = 0;
        let isHL = false;
        if (ins.reg16_1)
            isHL = true;
        if (isHL == false)
            data = this._regs[ins.reg1 as number];
        else {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        let bit0 = this.getBit(data, 0);
        let result = (data >> 1) + (this.getFlag(FLAG_C) << 7);
        this.setFlag(FLAG_C, bit0);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
        this.setFlagsZ(result);
        if (isHL == false)
            this.setReg(ins.reg1, result);
        else
            this.write(this.address, result);
    }


    // Shift n left into Carry. LSB of n set to 0
    SLA(ins: any) {
        let data = 0;
        let isHL = false;
        if (ins.reg16_1)
            isHL = true;
        if (isHL == false)
            data = this._regs[ins.reg1 as number];
        else {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        let bit7 = this.getBit(data, 7);
        let result = (data << 1);
        this.setFlag(FLAG_C, bit7);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
        this.setFlagsZ(result);
        if (isHL == false)
            this.setReg(ins.reg1, result);
        else
            this.write(this.address, result);
    }

    // Shift n right into Carry. MSB doesn't change.
    SRA(ins: any) {
        let data = 0;
        let isHL = false;
        if (ins.reg16_1)
            isHL = true;
        if (isHL == false)
            data = this._regs[ins.reg1 as number];
        else {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        let bit0 = this.getBit(data, 0);
        let bit7 = this.getBit(data, 7);
        let result = (data >> 1) + (bit7 << 7);
        this.setFlag(FLAG_C, bit0);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
        this.setFlagsZ(result);
        if (isHL == false)
            this.setReg(ins.reg1, result);
        else
            this.write(this.address, result);
    }

    // SRL B
    // Shift n right into Carry. MSB set to 0
    SRL(ins: any) {
        let data = 0;
        let isHL = false;
        if (ins.reg16_1)
            isHL = true;
        if (isHL == false)
            data = this._regs[ins.reg1 as number];
        else {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        let bit1 = this.getBit(data, 0);
        let result = (data >> 1);
        this.setFlag(FLAG_C, bit1);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
        this.setFlagsZ(result);
        if (isHL == false)
            this.setReg(ins.reg1, result);
        else
            this.write(this.address, result);
    }

    SWAP(ins: any) {
        let data = 0;
        let isHL = false;
        if (ins.reg16_1)
            isHL = true;
        if (isHL == false)
            data = this._regs[ins.reg1 as number];
        else {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        let lownibble = data & 0xF;
        let highnibble = data & 0xF0;
        let result = (lownibble << 4) + (highnibble >> 4);
        this.setFlag(FLAG_C, 0);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
        this.setFlagsZ(result);
        if (isHL == false)
            this.setReg(ins.reg1, result);
        else
            this.write(this.address, result);
    }

    // Test bit b in register r.
    BIT(ins: any) {
        let data = 0;
        if (ins.reg16_1) {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        else {
            data = this._regs[ins.reg1 as number];
        }

        let bit = this.getBit(data, ins.bit);
        this.setFlagsZ(bit);
        this.setFlag(FLAG_H, 1);
        this.setFlag(FLAG_N, 0);
    }

    // Set bit b in register r.
    SET(ins: any) {
        let data = 0;
        if (ins.reg16_1) {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        else {
            data = this._regs[ins.reg1 as number];
        }

        let newbyte = this.setBit(data, ins.bit, 1);

        if (ins.reg16_1) {
            this.write(this.address, newbyte);
        }
        else {
            this.setReg(ins.reg1, newbyte);
        }
    }

    // Reset bit b in register r.
    RES(ins: any) {
        let data = 0;
        if (ins.reg16_1) {
            this.address = this.getReg16(HL);
            data = this.read(this.address);
        }
        else {
            data = this._regs[ins.reg1 as number];
        }

        let newbyte = this.setBit(data, ins.bit, 0);

        if (ins.reg16_1) {
            this.write(this.address, newbyte);
        }
        else {
            this.setReg(ins.reg1, newbyte);
        }
    }

    // ADD HL,BC
    //16 bit add of 2 numbers into HL
    //HALF CARRY: Set if there is a carry from bit 11; otherwise reset.
    //CARRY: Set if there is a carry from bit 15; otherwise reset
    AddToHL(ins: any) {
        let val1 = this.getReg16(HL);
        let reg16 = ins.reg16_1;
        let reg1 = reg16["reg1"] as number;
        let reg2 = reg16["reg2"] as number;
        let val2 = this.getReg16(ins.reg16_1);
        let low1 = this._regs[L];
        let low2 = this._regs[reg2];
        let high1 = this._regs[H];
        let high2 = this._regs[reg1];

        if (ins.reg16_1 == SP) {
            low2 = this.getLowNibble(this.SP);
            high2 = this.getHighNibble(this.SP);
            val2 = this.SP;
        }

        let lowcarry = (low1 + low2) > 255 ? 1 : 0;
        let halfcarry = (((high1 & 0x0F) + (high2 & 0x0F) + lowcarry) & 0x10);
        let carry = (high1 + high2 + lowcarry) > 255 ? 1 : 0;

        //do the add
        this.setReg16(HL, val1 + val2);
        this.setFlag(FLAG_N, 0);
        this.setFlag(FLAG_C, carry);
        this.setFlag(FLAG_H, halfcarry);


    }

    //The STOP command halts the GameBoy processor 
    //and screen until any button is pressed.
    STOP(ins: any) {

        this.PC++;
        let speed_register = this.read(0xFF4D);

        //color gameboy toggle speed
        //TODO - switch to use new speed immediately instead of on the next frame
        if (BitHelper.getBit(speed_register, 0) == 1) {
            // if (this.speedmode == 1)
            //     this.speedmode = 0;
            // else
            //     this.speedmode = 1;

            let new_speed_register = 0;
            new_speed_register = BitHelper.setBit(new_speed_register, 7, this.speedmode);
            this.gameboy.memory.ram[0xFF4D] = new_speed_register;

        }
        else
            this.stop_mode = true;
    }

    //  Decimal adjust register A.
    //  This instruction adjusts register A so that the
    //  correct representation of Binary Coded Decimal (BCD)
    //  is obtained.
    DAA(ins: any) {
        if (this.getFlag(FLAG_N)) {
            if (this.getFlag(FLAG_C)) this.A -= 0x60;
            if (this.getFlag(FLAG_H)) this.A -= 0x06;
        } else {
            if (this.A > 0x99 || this.getFlag(FLAG_C)) { this.A += 0x60; this.setFlag(FLAG_C, 1) }
            if ((this.A & 0x0f) > 0x09 || this.getFlag(FLAG_H)) this.A += 0x06;
        }

        this.setFlagsZ(this.A);
        this.setFlag(FLAG_H, 0);
    }

    //flip all the bits in register A (Complement A)
    CPL(ins: any) {
        this.A = ~this.A;
        this.setFlag(FLAG_N, 1);
        this.setFlag(FLAG_H, 1);
    }

    //Set carry flag
    SCF(ins: any) {
        this.setFlag(FLAG_C, 1);
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
    }

    //flip carry flag
    CCF(ins: any) {
        this.setFlag(FLAG_H, 0);
        this.setFlag(FLAG_N, 0);
        if (this.getFlag(FLAG_C))
            this.setFlag(FLAG_C, 0);
        else
            this.setFlag(FLAG_C, 1);
    }

    //Halt CPU - system clock and cpu is stopped until interrupt or reset
    HALT(ins: any) {
        this.halt_mode = true;
    }

    //like JSR or jump soubroutine
    //assembly version of calling a function
    //save the return address on the stack
    CALL(ins: any) {
        this.SP -= 2;
        let returnProgramCounter = this.PC + 2;
        let lowNibble = this.read(this.PC);
        let highNibble = this.read(this.PC + 1);
        this.PC = this.convertTwo8sto16(highNibble, lowNibble);
        this.write(this.SP, returnProgramCounter & 0xFF); //first low byte
        this.write(this.SP + 1, returnProgramCounter >> 8); //then high byte
    }

    //call if not zero
    CALL_NZ(ins: any) {
        if (this.getFlag(FLAG_Z)) {
            this.PC += 2;
            return;
        }
        this.cycles += 12;
        this.CALL(ins);
    }

    //call if zero
    CALL_Z(ins: any) {
        if (!this.getFlag(FLAG_Z)) {
            this.PC += 2;
            return;
        }
        this.cycles += 12;
        this.CALL(ins);
    }

    //call if not carry flag
    CALL_NC(ins: any) {
        if (this.getFlag(FLAG_C)) {
            this.PC += 2;
            return;
        }
        this.cycles += 12;
        this.CALL(ins);
    }

    //call if carry
    CALL_C(ins: any) {
        if (!this.getFlag(FLAG_C)) {
            this.PC += 2;
            return;
        }
        this.cycles += 12;
        this.CALL(ins);
    }

    //return from a CALL function
    RETURN(ins: any) {
        let lownibble = this.read(this.SP);
        let highnibble = this.read(this.SP + 1);
        this.SP += 2;
        this.PC = this.convertTwo8sto16(highnibble, lownibble);
    }

    //return if not zero
    RET_NZ(ins: any) {
        if (this.getFlag(FLAG_Z)) {
            return;
        }
        this.cycles += 12;
        this.RETURN(ins);
    }

    //return if zero
    RET_Z(ins: any) {
        if (!this.getFlag(FLAG_Z)) {
            return;
        }
        this.cycles += 12;
        this.RETURN(ins);
    }

    //return if not carry flag
    RET_NC(ins: any) {
        if (this.getFlag(FLAG_C)) {
            return;
        }
        this.cycles += 12;
        this.RETURN(ins);
    }

    //return if carry
    RET_C(ins: any) {
        if (!this.getFlag(FLAG_C)) {
            return;
        }
        this.cycles += 12;
        this.RETURN(ins);
    }

    //pop two bytes off of stack and push them
    //onto a 16 bit register
    POP(ins: any) {
        let low = this.read(this.SP);
        let high = this.read(this.SP + 1);
        this.setReg16(ins.reg16_1, this.convertTwo8sto16(high, low));

        //mask lower 4 bits
        this.F = this.F & 0xF0;
        this.SP += 2;
    }

    //push two bytes onto stack
    //from 16 bit register
    PUSH(ins: any) {
        let low = this.getReg(ins.reg16_1.reg1);
        let high = this.getReg(ins.reg16_1.reg2);
        this.write(this.SP - 1, low); //first low byte
        this.write(this.SP - 2, high); //then high byte
        this.SP -= 2;
    }

    //CB instruction
    CB(ins: any) {
        //do nothing - opcode is in next byte
    }

    //jump to predefined addresses in the first page of memory
    RST(ins: any) {
        this.SP -= 2;
        let returnProgramCounter = this.PC;
        let low = this.getLowNibble(returnProgramCounter);
        let high = this.getHighNibble(returnProgramCounter)
        this.write(this.SP, low); //first low byte
        this.write(this.SP + 1, high); //then high byte
        this.PC = ins.address;
    }

    //return from interrupt
    RETI(ins: any) {
        this.IME = true;
        this.RETURN(ins);
    }

    //disable master interrupt flag
    DI(ins: any) {
        this.IME = false;
    }

    //enable master interrupt flag
    EI(ins: any) {
        this.IME = true;
    }

    //Load into memory address $FF00 + n.
    LDH(ins: any) {

        let address = this.read(this.PC);
        this.PC++;

        // LDH A,(a8)
        if (ins.reg1 == A) {
            this.A = this.read(0xFF00 + address);
        }
        // LDH (a8),A
        else {
            this.write(0xFF00 + address, this.A);
        }
    }

    //Load into memory address $FF00 + Register C.
    LDC(ins: any) {

        // LD A,(C)
        if (ins.reg1 == A) {
            this.A = this.read(0xFF00 + this.C);
        }
        // LD (C),A
        else {
            this.write(0xFF00 + this.C, this.A);
        }
    }

    //add immediate signed byte to SP
    ADD_SP(ins: any) {
        let value = this.read(this.PC);
        this.PC++;

        value = this.getSignedByteValue(value);

        let carry = (((this.SP & 0xFF) + (value & 0xFF)) & 0x100);
        let half_carry = (((this.SP & 0x0F) + (value & 0x0F)) & 0x010);

        this.SP += value;

        //prevent SP from going higher than 0xFFFF
        //TODO - should I do this everywhere?
        this.SP &= 0xFFFF;


        this.setFlag(FLAG_C, carry);
        this.setFlag(FLAG_H, half_carry);
        this.setFlag(FLAG_Z, 0);
        this.setFlag(FLAG_N, 0);

    }

    // Put SP + n effective address into HL.
    LD_HL_SPADD(ins: any) {
        let value = this.read(this.PC);
        this.PC++;

        value = this.getSignedByteValue(value);

        let carry = (((this.SP & 0xFF) + (value & 0xFF)) & 0x100);
        let half_carry = (((this.SP & 0x0F) + (value & 0x0F)) & 0x010);
        let result = this.SP + value;

        this.setReg16(HL, result);

        this.setFlag(FLAG_C, carry);
        this.setFlag(FLAG_H, half_carry);
        this.setFlag(FLAG_Z, 0);
        this.setFlag(FLAG_N, 0);

    }

    // LD SP,HL
    LD_SP_HL(ins: any) {
        this.SP = this.getReg16(HL);
    }


}



class BitHelper {

    static mask255(data: number): number {
        return data & 0xFF;
    }

    static getBit(byte: number, bit: number): number {
        return (byte >> bit) & 1;
    }

    static setBit(byte: number, bit: number, value: number): number {
        if (value > 0)
            return byte | (1 << bit);
        else
            return byte & ~(1 << bit);
    }

    static toggleBit(byte: number, bit: number): number {
        return byte ^ (1 << bit);
    }

}


const buf = Buffer.create(120);
buf.fill(4);

//TODO - this might be a faster routine for copying rows of data
// scene.backgroundImage().setRows()

//render initial screen
for (let x = 0; x < 160; x++) {
    scene.backgroundImage().setRows(x, buf);
    if (x == 80)
        buf.fill(9);
}

let controllerA = false;
let controllerB = false;
let controllerStart = false;
let controllerStartCounter = 0;
let controllerLeft = false;
let controllerRight = false;
let controllerUp = false;
let controllerDown = false;


class Gameboy {

    // SCREEN_MAIN: VideoScreen;
    SCREEN_WIDTH = 160;
    SCREEN_HEIGHT = 144;

    // SCREEN_DEBUG: VideoScreen;
    SCREEN_DEBUG_WIDTH = 400;
    SCREEN_DEBUG_HEIGHT = 300;


    cpu: CPU;
    ppu: PPU;
    memory: Memory;
    cartridge: Cartridge;
    // apu: APU;
    // fps_controller: FPSController;
    rom_name: string = '';
    loadSavestateAfterBoot: boolean = false;
    dualPlayerMode: boolean = false;

    //debug
    DEBUGMODE: boolean = true;
    PAUSED: boolean = false;
    SAMPLEPROGRAM: boolean = false;

    // inputController: InputController;
    advanceFrameMode: boolean = false;
    debug_view_chr = false;
    debug_view_nametable = true;
    debugNametable = 1; //which nametable is viewed on debug screen
    debugDisableFPS = false;
    debugProgram: string = ''; //view stats via rivets
    debugMemory: string = ''; //view stats via rivets
    debugStats: string = ''; //view stats via rivets
    debugStats2: string = ''; //view stats via rivets
    debugMemPage = 0x100; //which page of memory map to view
    debugMemPageFollow = true;
    debugSoundMode = false;
    debugSquare1Visual = '';
    debugSquare2Visual = '';
    debugTriangleVisual = '';
    debugSquare1Note = '';
    debugSquare2Note = '';
    debugTriangleNote = '';
    debugSoundStats = ''; //view sound stats
    debugDisableSound: boolean = false;
    debugDrawMapMode: boolean = false;

    //performance tuning
    timeDiff = 0;
    timeCalc = 0;
    timeDiffAvg = 0;    //only used for average mode

    disableBoot = true;

    //gameboynumber
    gameboynumber: number = 1;

    //counters
    frameCounter = 0; //for audio processing
    serialClockCounter = 0; //for serial link timing
    cycle_counter_debug = 0; //for debugging

    constructor() {
        this.memory = new Memory(this);
        this.cpu = new CPU(this);
        this.ppu = new PPU(this);
        this.cartridge = new Cartridge(this);
        this.cartridge.load();

        this.cpu.reset();
        if (this.disableBoot == false) {
            this.memory.boot_finished = false;
            this.cpu.PC = 0x00;
        }

    }


    frame() {

        let combinedCycles = 0; //for gbc cycles at double speed

        //for debugging
        let cycle_counter = 0; //17556 machine cycles a frame

        if (this.cpu.speedmode == 0) { //gb
            while (this.ppu.frame_complete == false) {

                //pass the cpu cycles to the ppu
                let cycles = this.cpu.clock();

                //advance the ppu based on number of cpu
                this.ppu.clock(cycles);

                cycle_counter++;

            }
            this.ppu.frame_complete = false;
        }

    }
}

class Cartridge {

    gameboy: Gameboy;
    game_title: string = '';
    licensee_code: number = 0;
    licensee_name: string = '';

    mode_label: string = '(GB)'; //if it supports GB, CGB, or BOTH
    super_gb: boolean = false; //super gameboy functions
    cartridge_type_label: string = '';
    rom_size_code: number = 0; //Specifies the ROM Size of the cartridge
    ram_size_code: number = 0; //Specifies the size of the external RAM in the cartridge (if any)
    destination_code: number; //Specifies if this version of the game is supposed to be sold in japan, or anywhere else.
    header_checksum: number; //Contains an 8 bit checksum across the cartridge header bytes 0134-014C
    rom_version: number = 0; //Specifies the version number of the game. 
    pre_boot_page: number[] = [];
    force_gameboy_mode: boolean = false;
    force_gameboycolor_mode: boolean = false;

    //for loading an external .sav file
    load_save: Buffer;

    chr_viewer_mode: boolean = false;

    constructor(gameboy: Gameboy) {
        this.gameboy = gameboy;
    }

    load() {
        this.loadHeader();
    }

    loadHeader() {

        //hard code for now
        let prgSize = (romImage.width * romImage.height) / 2;
        this.gameboy.memory.prgData = Buffer.create(prgSize);


        //read the rom data out of the image
        //each byte is 2 pixels wide since each pixel is only 4 bits
        let counterX = 0;
        let counterY = 0;
        for (let i = 0; i < prgSize; i++) {
            let pixel1 = romImage.getPixel(counterX, counterY);
            let pixel2 = romImage.getPixel(counterX + 1, counterY);
            let num = (pixel1 << 4) + pixel2;
            this.gameboy.memory.prgData[i] = num;

            counterX += 2;
            if (counterX == romImage.width) {
                //if we hit the edge move to the next row of image data
                counterX = 0;
                counterY++;
            }
        }

        //game title
        for (let i = 0x134; i < 0x143; i++) {
            let char = this.gameboy.memory.prgData[i];
            if (char == 0)
                break;
            this.game_title += String.fromCharCode(char);
        }

        if (!this.game_title)
            this.game_title = "NO TITLE";

        //color gameboy
        if (!this.force_gameboy_mode) {
            if (this.gameboy.memory.prgData[0x143] == 0x80 || this.gameboy.memory.prgData[0x143] == 0xC0) {
                // this.gameboy.memory.color_gb = true;
                this.mode_label = '(GB AND CGB)';
                if (this.gameboy.memory.prgData[0x143] == 0xC0) {
                    // this.gameboy.memory.color_only = true;
                    this.mode_label = '(CGB ONLY)';
                }
                console.log('color gameboy title detected');
            }
        }

        //for colorization of old gb games
        if (this.force_gameboycolor_mode) {
            this.gameboy.memory.color_gb = true;
            this.gameboy.ppu.colorize_gb_games = true;
            this.gameboy.disableBoot = false;
        }

        if (this.gameboy.memory.prgData[0x146] == 0x03) {
            this.super_gb = true;
            console.log('super gameboy title detected');
        }

        //cartridge type
        this.gameboy.memory.cartridge_type = this.gameboy.memory.prgData[0x147];
        this.cartridge_type_label = this.getCartridgeType(this.gameboy.memory.cartridge_type);

        //rom size
        this.rom_size_code = this.gameboy.memory.prgData[0x148];

        //ram size
        this.ram_size_code = this.gameboy.memory.prgData[0x149];
        if (this.ram_size_code) {
            if (this.ram_size_code == 1) this.gameboy.memory.externalRam = Buffer.create(1024 * 2);
            if (this.ram_size_code == 2) this.gameboy.memory.externalRam = Buffer.create(1024 * 8);
            if (this.ram_size_code == 3) this.gameboy.memory.externalRam = Buffer.create(1024 * 32);

        }
        else {
            this.gameboy.memory.externalRam = Buffer.create(0x2000);
        }

        //for loading external save files
        if (this.load_save) {
            for (let i = 0; i < this.load_save.length; i++) {
                this.gameboy.memory.externalRam[i] = this.load_save[i];
            }
        }


        //destination code
        this.destination_code = this.gameboy.memory.prgData[0x14A];

        //licensee code
        this.licensee_code = this.gameboy.memory.prgData[0x14B];
        this.licensee_name = "blah"; //this.getLincensee(this.licensee_code);

        //Mask ROM Version number
        this.rom_version = this.gameboy.memory.prgData[0x14C];

        //header checksum
        this.header_checksum = this.gameboy.memory.prgData[0x14D];

        //Global Checksum 0x14E-0x14F
        //TODO


        if (this.gameboy.memory.cartridge_type == 21 || this.gameboy.memory.cartridge_type == 22 ||
            this.gameboy.memory.cartridge_type == 23 || this.gameboy.memory.cartridge_type > 30 ||
            (this.gameboy.memory.cartridge_type >= 7 && this.gameboy.memory.cartridge_type <= 14)) {
            console.log('mapper not implemented');
        }

        console.log('Cartridge Type: ' + this.cartridge_type_label + " Number: " + this.gameboy.memory.cartridge_type);
        console.log('Game Title: ' + this.game_title);
        console.log('Licensee Name: ' + this.licensee_name);
        console.log('Mode: ' + this.mode_label);

        if (this.ram_size_code)
            console.log('Ram Size: ' + this.ram_size_code + ", " + this.gameboy.memory.externalRam.length);


        console.log('finished loading rom');

    }

    getCartridgeType(code: number) {

        let cart_type = '';
        let cartridge_types = [
            0x00, "ROM ONLY",
            0x01, "MBC1",
            0x02, "MBC1+RAM",
            0x03, "MBC1+RAM+BATTERY",
            0x05, "MBC2",
            0x06, "MBC2+BATTERY",
            0x08, "ROM+RAM",
            0x09, "ROM+RAM+BATTERY",
            0x0B, "MMM01",
            0x0C, "MMM01+RAM",
            0x0D, "MMM01+RAM+BATTERY",
            0x0F, "MBC3+TIMER+BATTERY",
            0x10, "MBC3+TIMER+RAM+BATTERY",
            0x11, "MBC3",
            0x12, "MBC3+RAM",
            0x13, "MBC3+RAM+BATTERY",
            0x15, "MBC4",
            0x16, "MBC4+RAM",
            0x17, "MBC4+RAM+BATTERY",
            0x19, "MBC5",
            0x1A, "MBC5+RAM",
            0x1B, "MBC5+RAM+BATTERY",
            0x1C, "MBC5+RUMBLE",
            0x1D, "MBC5+RUMBLE+RAM",
            0x1E, "MBC5+RUMBLE+RAM+BATTERY",
            0xFC, "POCKET CAMERA",
            0xFD, "BANDAI TAMA5",
            0xFE, "HuC3",
            0xFF, "HuC1+RAM+BATTERY"
        ];

        for (let i = 0; i < cartridge_types.length; i++) {
            let element = cartridge_types[i];
            if (element == code) {
                cart_type = cartridge_types[i + 1] as string;
            }
        }

        return cart_type;
    }


    cgb_boot: number[] = [];
}

let gameboy = new Gameboy();

let background = scene.backgroundImage();

background.printCenter("Game: " + gameboy.cartridge.game_title, 35, 15, image.font8)
background.printCenter("Width: " + romImage.width, 55, 15, image.font8)
background.printCenter("Pixels: " +
    romImage.getPixel(0, 0) + " " +
    romImage.getPixel(1, 0) + " " +
    romImage.getPixel(2, 0) + " " +
    romImage.getPixel(3, 0) + " " +
    romImage.getPixel(4, 0),
    75, 15, image.font8)

let debugSprite = sprites.create(img`
    .
`);

debugSprite.x = 23;
debugSprite.y = 20;

class FPSCounter {
    lastCalledTime: number;
    fpscounter: number;
    currentfps: number;
    constructor() {
        this.lastCalledTime = game.runtime();
        this.fpscounter = 0;
        this.currentfps = 0;
    }
    countFPS() {
        this.fpscounter++;
        let delta = (game.runtime() - this.lastCalledTime) / 1000;
        if (delta > 1) {
            this.currentfps = this.fpscounter;
            this.fpscounter = 0;
            this.lastCalledTime = game.runtime();
        }
    }
}

let fpscounter = new FPSCounter();
let enableDrawing = true;

//only enable rendering every other frame
//to improve the performance
game.onUpdate(() => {
    fpscounter.countFPS();
    enableDrawing = true;
    gameboy.frame();

    fpscounter.countFPS();
    enableDrawing = false;
    gameboy.frame();
    debugSprite.sayText("FPS: " + fpscounter.currentfps);
})

//PRESSED
controller.up.onEvent(ControllerButtonEvent.Pressed, function () {
    controllerUp = true;
});
controller.down.onEvent(ControllerButtonEvent.Pressed, function () {
    controllerDown = true;
});
controller.left.onEvent(ControllerButtonEvent.Pressed, function () {
    controllerLeft = true;
});
controller.right.onEvent(ControllerButtonEvent.Pressed, function () {
    controllerRight = true;
});
controller.A.onEvent(ControllerButtonEvent.Pressed, function () {
    controllerA = true;
});
controller.B.onEvent(ControllerButtonEvent.Pressed, function () {
    controllerB = true;
});
controller.menu.onEvent(ControllerButtonEvent.Pressed, function () {
    controllerStart = true;
});


//RELEASED
controller.up.onEvent(ControllerButtonEvent.Released, function () {
    controllerUp = false;
});
controller.down.onEvent(ControllerButtonEvent.Released, function () {
    controllerDown = false;
});
controller.left.onEvent(ControllerButtonEvent.Released, function () {
    controllerLeft = false;
});
controller.right.onEvent(ControllerButtonEvent.Released, function () {
    controllerRight = false;
});
controller.A.onEvent(ControllerButtonEvent.Released, function () {
    controllerA = false;
});
controller.B.onEvent(ControllerButtonEvent.Released, function () {
    controllerB = false;
});
controller.menu.onEvent(ControllerButtonEvent.Released, function () {
    controllerStartCounter = 15;
});